<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Position Sync Monitor</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üîÑ</text></svg>">

    <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-NN3P9KC9');</script>
    <!-- End Google Tag Manager -->

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#4a9eff',
                        dark: { 900: '#0a0e1a', 800: '#0f1420', 700: '#151b2e', 600: '#1a2137', 500: '#2a3550' }
                    }
                }
            }
        }
    </script>

    <!-- External Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/ccxt@4.5.11/dist/ccxt.browser.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/ethers@6.15.0/dist/ethers.umd.min.js"></script>

    <style>
        /* Table styles */
        .table-container {
            overflow-x: auto;
            border-radius: 8px;
            border: 1px solid #2a3550;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }
        .table-container table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.75rem;
            background-color: #0f1420;
        }
        .table-container thead {
            background: linear-gradient(to right, #1a2137, #151b2e);
        }
        .table-container thead tr th {
            padding: 10px 12px;
            text-align: left;
            color: #d1d5db;
            font-weight: 600;
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            border-bottom: 2px solid #2a3550;
        }
        .table-container tbody tr {
            border-bottom: 1px solid #2a3550;
        }
        .table-container tbody tr:nth-child(even) { background-color: #0f1420; }
        .table-container tbody tr:nth-child(odd) { background-color: #151b2e; }
        .table-container tbody tr:hover {
            background-color: #1a2137 !important;
        }
        .table-container tbody td {
            padding: 10px 12px;
            color: #e5e7eb;
            font-size: 0.75rem;
        }

        /* Side badges */
        .side-long {
            color: #10b981;
            background-color: rgba(16, 185, 129, 0.1);
            padding: 3px 8px;
            border-radius: 4px;
            font-weight: 600;
            font-size: 0.7rem;
            display: inline-block;
        }
        .side-short {
            color: #ef4444;
            background-color: rgba(239, 68, 68, 0.1);
            padding: 3px 8px;
            border-radius: 4px;
            font-weight: 600;
            font-size: 0.7rem;
            display: inline-block;
        }

        /* Activity log */
        #activity-log {
            max-height: 300px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.75rem;
        }
        #activity-log::-webkit-scrollbar {
            width: 8px;
        }
        #activity-log::-webkit-scrollbar-track {
            background: #0f1420;
        }
        #activity-log::-webkit-scrollbar-thumb {
            background: #2a3550;
            border-radius: 4px;
        }
        #activity-log::-webkit-scrollbar-thumb:hover {
            background: #4a9eff;
        }

        .log-entry {
            padding: 4px 8px;
            border-left: 2px solid transparent;
            margin-bottom: 2px;
        }
        .log-entry.success { border-left-color: #10b981; }
        .log-entry.error { border-left-color: #ef4444; }
        .log-entry.warning { border-left-color: #ffa726; }
        .log-entry.info { border-left-color: #4a9eff; }

        /* Monitoring Status Indicator */
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .status-indicator.active {
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }

        /* Stat card animation */
        @keyframes countUp {
            from { transform: scale(1); }
            to { transform: scale(1.1); }
        }
        .stat-card.updated {
            animation: countUp 0.3s ease-in-out;
        }
    </style>

</head>
<body class="bg-dark-900 text-gray-200">
    <div class="container mx-auto px-4 py-4 max-w-[1600px]">

        <!-- Header -->
        <header class="text-center mb-4 bg-gradient-to-br from-dark-600 to-dark-800 rounded-lg p-4 shadow-lg">
            <div class="flex justify-between items-center">
                <div class="flex-1"></div>
                <div class="flex-1 text-center">
                    <h1 class="text-3xl font-bold text-primary mb-1">üîÑ Position Sync Monitor</h1>
                    <p class="text-gray-400 text-sm">Real-time copy trading synchronization</p>
                </div>
                <div class="flex-1 text-right">
                    <span class="text-xs text-gray-500 font-mono" id="version-display">v0.0.0</span>
                </div>
            </div>
        </header>

        <!-- Security & Privacy Notice -->
        <div class="mb-4 bg-gradient-to-r from-green-900/20 to-blue-900/20 border border-green-500/30 rounded-lg p-3">
            <div class="flex items-start gap-3">
                <div class="text-2xl">üîí</div>
                <div class="flex-1">
                    <h3 class="text-sm font-semibold text-green-400 mb-1">100% Client-Side & Private</h3>
                    <p class="text-xs text-gray-300 leading-relaxed">
                        This application runs <strong>entirely in your browser</strong>. No backend servers, no data storage, no private key transmission.
                        Your private keys never leave your device and are only used locally to sign transactions.
                        All API calls are made directly from your browser to public blockchain nodes and exchanges.
                    </p>
                </div>
            </div>
        </div>

        <!-- Quick Start Guide -->
        <div class="mb-4 bg-gradient-to-r from-blue-900/20 to-purple-900/20 border border-blue-500/30 rounded-lg p-3">
            <div class="flex items-start gap-3">
                <div class="text-2xl">üìö</div>
                <div class="flex-1">
                    <h3 class="text-sm font-semibold text-blue-400 mb-2">Quick Start Guide</h3>

                    <!-- Setup Steps -->
                    <div class="mb-3 text-xs text-gray-300">
                        <div class="font-medium text-blue-300 mb-1.5">Setup Steps:</div>
                        <ol class="list-decimal list-inside space-y-1 ml-2">
                            <li>Select an AI trader from the dropdown (or enter custom address)</li>
                            <li>Enter your wallet private key</li>
                            <li>Ensure you have <strong>enough USDC</strong> and <strong>CRO</strong> (for gas) in your wallet</li>
                            <li>Click <strong>"Start Monitoring"</strong> to begin copy trading</li>
                        </ol>
                    </div>

                    <!-- Important Notes -->
                    <div class="mb-3 bg-orange-900/20 border border-orange-500/30 rounded p-2 text-xs">
                        <div class="font-medium text-orange-400 mb-1">‚ö†Ô∏è Important Notes:</div>
                        <ul class="list-disc list-inside space-y-0.5 ml-2 text-gray-300">
                            <li><strong>BNB not supported:</strong> Moonlander doesn't list BNB. If you choose DeepSeek, have <strong>$300-$500 USDC</strong> minimum (BNB positions will be skipped)</li>
                            <li><strong>Minimum balance:</strong> $50 USDC recommended, but higher balances work better for copying multiple positions</li>
                            <li><strong>Gas fees:</strong> Keep some CRO in your wallet for transaction fees</li>
                        </ul>
                    </div>

                    <!-- Safety Tips -->
                    <div class="mb-3 bg-red-900/20 border border-red-500/30 rounded p-2 text-xs">
                        <div class="font-medium text-red-400 mb-1">üõ°Ô∏è Safety Tips:</div>
                        <ul class="list-disc list-inside space-y-0.5 ml-2 text-gray-300">
                            <li><strong>Always start with a FRESH WALLET</strong> - Use a new wallet dedicated only to copy trading</li>
                            <li><strong>Always DYOR</strong> (Do Your Own Research) - Understand the risks before copying any trader</li>
                            <li><strong>Always start with a small amount</strong> - Test with minimal funds first, then scale up gradually</li>
                        </ul>
                    </div>

                    <!-- Quick Links -->
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-2">
                        <a href="https://nof1.ai/" target="_blank" rel="noopener noreferrer"
                           class="flex items-center gap-2 px-3 py-2 bg-dark-800/50 hover:bg-dark-700/50 border border-dark-500 rounded transition-colors group">
                            <span class="text-base">ü§ñ</span>
                            <div class="flex-1">
                                <div class="font-medium text-blue-400 group-hover:text-blue-300 text-xs">AI Bot Performance</div>
                                <div class="text-gray-400 text-xs">View live stats & rankings</div>
                            </div>
                            <span class="text-gray-500 group-hover:text-gray-400">‚Üó</span>
                        </a>
                        <a href="https://moonlander.trade/" target="_blank" rel="noopener noreferrer"
                           class="flex items-center gap-2 px-3 py-2 bg-dark-800/50 hover:bg-dark-700/50 border border-dark-500 rounded transition-colors group">
                            <span class="text-base">üåô</span>
                            <div class="flex-1">
                                <div class="font-medium text-purple-400 group-hover:text-purple-300 text-xs">Moonlander Trading</div>
                                <div class="text-gray-400 text-xs">Check positions & trade</div>
                            </div>
                            <span class="text-gray-500 group-hover:text-gray-400">‚Üó</span>
                        </a>
                    </div>
                </div>
            </div>
        </div>

        <!-- Configuration Form -->
        <section class="bg-dark-700 rounded-lg shadow-lg p-4 mb-4">
            <h2 class="text-lg font-semibold text-primary mb-3">‚öôÔ∏è Configuration</h2>
            <form id="config-form" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-3">
                <div>
                    <label class="block text-sm font-medium text-gray-400 mb-1">Select Trader</label>
                    <select id="trader-select"
                        class="w-full px-2.5 py-1.5 text-sm bg-dark-800 border border-dark-500 rounded focus:border-primary focus:ring-1 focus:ring-primary outline-none text-gray-200">
                        <option value="">-- Select a trader --</option>
                        <option value="0x1b7a7d099a670256207a30dd0ae13d35f278010f">Gemini 2.5 Pro</option>
                        <option value="0x67293d914eafb26878534571add81f6bd2d9fe06">GPT-5</option>
                        <option value="0x7a8fd8bba33e37361ca6b0cb4518a44681bad2f3">Qwen3 Max</option>
                        <option value="0x59fa085d106541a834017b97060bcbbb0aa82869">Claude Sonnet 4.5</option>
                        <option value="0x56d652e62998251b56c8398fb11fcfe464c08f84">Grok-4</option>
                        <option value="0xc20ac4dc4188660cbf555448af52694ca62b0734">DeepSeek V3.1</option>
                        <option value="custom">Custom Address...</option>
                    </select>
                </div>

                <div id="custom-address-container" style="display: none;">
                    <label class="block text-sm font-medium text-gray-400 mb-1">Custom Trader Address</label>
                    <input type="text" id="trader-address" placeholder="0x..." required
                        class="w-full px-2.5 py-1.5 text-sm bg-dark-800 border border-dark-500 rounded focus:border-primary focus:ring-1 focus:ring-primary outline-none text-gray-200">
                </div>


                <div>
                    <label class="block text-sm font-medium text-gray-400 mb-1">
                        Wallet Private Key (Copy Trading)
                        <span class="text-xs text-green-400 ml-1" title="Your key never leaves your browser">üîí locally</span>
                    </label>
                    <input type="password" id="moonlander-private-key" placeholder="0x..." autocomplete="off"
                        title="Your private key is only used locally in your browser to sign transactions. It is never sent to any server."
                        class="w-full px-2.5 py-1.5 text-sm bg-dark-800 border border-dark-500 rounded focus:border-primary focus:ring-1 focus:ring-primary outline-none text-gray-200">
                </div>

                <div>
                    <label class="block text-sm font-medium text-gray-400 mb-1">Total Equity ($)</label>
                    <input type="number" id="copy-balance" placeholder="Auto-fetch from wallet" value="" min="100" step="1" readonly
                        class="w-full px-2.5 py-1.5 text-sm bg-dark-900 border border-dark-500 rounded text-gray-400 cursor-not-allowed">
                    <p class="text-xs text-gray-500 mt-1">Free balance + positions value</p>
                </div>


                <div class="md:col-span-2 lg:col-span-4 flex gap-2 items-center">
                    <button type="button" id="start-button"
                        class="px-4 py-2 text-sm font-medium bg-green-600 hover:bg-green-700 text-white rounded transition">
                        ‚ñ∂Ô∏è Start Monitoring
                    </button>
                    <button type="button" id="stop-button" disabled
                        class="px-4 py-2 text-sm font-medium bg-red-600 hover:bg-red-700 disabled:bg-gray-600 disabled:cursor-not-allowed text-white rounded transition">
                        ‚è∏Ô∏è Stop
                    </button>

                    <!-- Status Indicator -->
                    <div id="status-display" class="hidden ml-auto flex items-center gap-2 px-3 py-1.5 bg-dark-800 rounded border border-dark-500">
                        <div class="status-indicator w-3 h-3 rounded-full bg-green-500 active"></div>
                        <span class="text-sm font-medium text-gray-200">Monitoring Active</span>
                    </div>
                </div>
            </form>
        </section>


        <!-- Positions Grid -->
        <div class="grid grid-cols-1 lg:grid-cols-2 gap-4 mb-4">
            <!-- Trader Positions -->
            <section class="bg-dark-700 rounded-lg shadow-lg">
                <div class="p-4 border-b border-dark-500">
                    <div class="flex justify-between items-center mb-2">
                        <h2 class="text-lg font-semibold text-primary">üë§ Trader Positions</h2>
                        <span class="text-sm text-gray-400" id="trader-position-count">0 positions</span>
                    </div>
                    <div class="text-xs text-gray-500 flex gap-4">
                        <span>Balance: <span class="text-gray-300 font-medium" id="balance-trader-total">$0.00</span></span>
                        <span>Available: <span class="text-green-400 font-medium" id="balance-trader-available">$0.00</span></span>
                        <span>Margin: <span class="text-yellow-400 font-medium" id="balance-trader-margin">$0.00</span></span>
                        <span>Position Value: <span class="text-purple-400 font-medium" id="balance-trader-position-value">$0.00</span></span>
                        <span>PnL: <span class="font-medium" id="balance-trader-pnl">$0.00</span></span>
                        <span>Ratio: <span class="text-blue-400 font-medium" id="balance-trader-ratio">0.0%</span></span>
                    </div>
                </div>
                <div class="p-4">
                    <div class="table-container">
                        <table>
                            <thead>
                                <tr>
                                    <th>Symbol</th>
                                    <th>Side</th>
                                    <th class="text-right">Size</th>
                                    <th class="text-right">Entry</th>
                                    <th class="text-right">PnL</th>
                                    <th class="text-right">Stop Loss</th>
                                    <th class="text-right">Take Profit</th>
                                    <th class="text-right">Liq Price</th>
                                    <th class="text-right">Leverage</th>
                                    <th class="text-right">Margin</th>
                                    <th class="text-right">Position Value</th>
                                    <th class="text-right">Margin %</th>
                                </tr>
                            </thead>
                            <tbody id="trader-positions-body">
                                <tr><td colspan="12" class="text-center text-gray-500 py-4">Not monitoring</td></tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </section>

            <!-- Your Positions -->
            <section class="bg-dark-700 rounded-lg shadow-lg">
                <div class="p-4 border-b border-dark-500">
                    <div class="flex justify-between items-center mb-2">
                        <h2 class="text-lg font-semibold text-primary">üìç Your Positions</h2>
                        <span class="text-sm text-gray-400" id="user-position-count">0 positions</span>
                    </div>
                    <div class="text-xs text-gray-500 flex gap-4">
                        <span>Balance: <span class="text-gray-300 font-medium" id="balance-user-total">$0.00</span></span>
                        <span>Available: <span class="text-green-400 font-medium" id="balance-user-available">$0.00</span></span>
                        <span>Margin: <span class="text-yellow-400 font-medium" id="balance-user-margin">$0.00</span></span>
                        <span>Position Value: <span class="text-purple-400 font-medium" id="balance-user-position-value">$0.00</span></span>
                        <span>PnL: <span class="font-medium" id="balance-user-pnl">$0.00</span></span>
                        <span>Ratio: <span class="text-blue-400 font-medium" id="balance-user-ratio">0.0%</span></span>
                        <span class="ml-2 text-cyan-400">Scaling: <span class="font-medium" id="balance-scaling-factor">0.0%</span></span>
                    </div>
                </div>
                <div class="p-4">
                    <div class="table-container">
                        <table>
                            <thead>
                                <tr>
                                    <th>Symbol</th>
                                    <th>Side</th>
                                    <th class="text-right">Size</th>
                                    <th class="text-right">Entry</th>
                                    <th class="text-right">PnL</th>
                                    <th class="text-right">Stop Loss</th>
                                    <th class="text-right">Take Profit</th>
                                    <th class="text-right">Liq Price</th>
                                    <th class="text-right">Leverage</th>
                                    <th class="text-right">Margin</th>
                                    <th class="text-right">Position Value</th>
                                    <th class="text-right">Margin %</th>
                                </tr>
                            </thead>
                            <tbody id="user-positions-body">
                                <tr><td colspan="12" class="text-center text-gray-500 py-4">Not monitoring</td></tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </section>
        </div>

        <!-- Actions Panel -->
        <section class="bg-dark-700 rounded-lg shadow-lg mb-4">
            <div class="p-4 border-b border-dark-500">
                <h2 class="text-lg font-semibold text-primary">üîÑ Required Actions</h2>
            </div>
            <div class="p-4">
                <div id="actions-content" class="space-y-2">
                    <div class="text-center text-gray-500 py-4">Start monitoring to see actions</div>
                </div>
            </div>
        </section>

        <!-- Activity Log -->
        <section class="bg-dark-700 rounded-lg shadow-lg">
            <div class="p-4 border-b border-dark-500">
                <div class="flex justify-between items-center mb-3">
                    <h2 class="text-lg font-semibold text-primary">üìú Activity Log</h2>
                    <button id="clear-log-btn" class="px-3 py-1.5 text-xs font-medium bg-dark-600 hover:bg-dark-500 text-gray-200 rounded transition">
                        Clear
                    </button>
                </div>
                <div class="flex flex-wrap gap-4 text-xs text-gray-400">
                    <span>üí∞ Balance: <span class="text-gray-200 font-medium" id="stat-balance">$0.00</span></span>
                    <span>üìä Syncs: <span class="text-gray-200 font-medium" id="stat-syncs">0</span></span>
                    <span>‚ûï Added: <span class="text-green-400 font-medium" id="stat-added">0</span></span>
                    <span>‚ûñ Removed: <span class="text-red-400 font-medium" id="stat-removed">0</span></span>
                    <span>‚ùå Errors: <span class="text-red-400 font-medium" id="stat-errors">0</span></span>
                </div>
            </div>
            <div class="p-4">
                <div id="activity-log" class="bg-dark-800 rounded p-3 border border-dark-500">
                    <div class="log-entry info">
                        <span class="text-gray-500">[Ready]</span> Configure and start monitoring
                    </div>
                </div>
            </div>
        </section>
    </div>

    <script type="module">
        // Position Sync Monitor - Browser Implementation
        // Similar to test-position-sync.js but runs entirely in the browser

        // ============================================
        // VERSION
        // ============================================
        const VERSION = '0.2.5';
        const BUILD_DATE = '2025-10-29';

        // ============================================
        // CONFIGURATION CONSTANTS
        // ============================================

        // Trading Parameters
        const MIN_COPY_BALANCE = 50; // Minimum copy balance in USD
        const MIN_POSITION_VALUE = 20; // Minimum position margin in USD ($30 minimum to avoid dust positions)
        const SIZE_TOLERANCE = 0.25; // 25% position size tolerance before triggering adjustment (increased to prevent churn from price movements)
        const DEFAULT_SLIPPAGE_PERCENT = 10; // 10% slippage tolerance
        const DEFAULT_BROKER_ID = 1; // Moonlander broker ID

        // Gas Limits
        const GAS_LIMIT_OPEN_TRADE = 800000;
        const GAS_LIMIT_CLOSE_TRADE = 600000;
        const PYTH_UPDATE_FEE = '0.061'; // CRO fee for Pyth oracle update

        // Decimals
        const DECIMALS_USDC = 6; // USDC token decimals
        const DECIMALS_QTY = 10; // Position quantity decimals
        const DECIMALS_PRICE = 18; // Price decimals

        // Decimal conversion helpers (DRY principle - avoid magic numbers)
        const USDC_DIVISOR = 10 ** DECIMALS_USDC; // 1e6
        const QTY_DIVISOR = 10 ** DECIMALS_QTY; // 1e10
        const PRICE_DIVISOR = 10 ** DECIMALS_PRICE; // 1e18

        // Liquidation calculation
        const MAINTENANCE_MARGIN_RATIO = 0.90; // 90% of margin before liquidation

        // Price Calculation
        const STOP_LOSS_PERCENT_LONG = 50; // 50% of entry for long
        const STOP_LOSS_PERCENT_SHORT = 150; // 150% of entry for short
        const TAKE_PROFIT_PERCENT_LONG = 150; // 150% of entry for long
        const TAKE_PROFIT_PERCENT_SHORT = 50; // 50% of entry for short

        // API Endpoints
        const HYPERLIQUID_API_URL = 'https://api.hyperliquid.xyz';
        const PYTH_API_URL = 'https://hermes.pyth.network/api';

        // Sync Settings
        const DEFAULT_SYNC_INTERVAL = 10; // seconds
        const MAX_LOG_ENTRIES = 100; // Maximum activity log entries
        const MAX_SCALING_FACTOR = 1.0; // Maximum scaling factor (100% - never copy more than trader)
        const SAFETY_BUFFER_PERCENT = 1.0; // Maximum safety buffer (100% cap) - users can use full balance for smaller trials

        // ============================================
        // STATE VARIABLES
        // ============================================

        let monitorExchange = null;
        let moonlanderExchange = null;
        let syncInterval = null;
        let isMonitoring = false;
        let stats = {
            balance: MIN_COPY_BALANCE,
            syncs: 0,
            added: 0,
            removed: 0,
            errors: 0
        };
        let lastTraderPositions = [];
        let userPositions = [];
        let lastTradeTimestamp = null;
        let cachedMoonlanderWallet = null;

        // ============================================
        // UTILITY FUNCTIONS (DRY, KISS principles)
        // ============================================

        // Get or create Moonlander wallet (avoids repeated wallet instantiation)
        function getMoonlanderWallet() {
            const privateKey = elements.moonlanderPrivateKey.value.trim();
            if (!privateKey) {
                return null;
            }

            // Validate private key format (should be 0x followed by 64 hex characters)
            if (!privateKey.match(/^0x[0-9a-fA-F]{64}$/)) {
                throw new Error('Invalid private key format. Must be 0x followed by 64 hexadecimal characters.');
            }

            // Cache wallet (create once per session)
            if (!cachedMoonlanderWallet) {
                cachedMoonlanderWallet = new ethers.Wallet(privateKey);
            }

            return cachedMoonlanderWallet;
        }

        // Symbol utilities for consistent symbol handling (Single Responsibility)
        const SymbolUtils = {
            // Convert to Moonlander format: "BTC" -> "BTC/USD"
            toMoonlanderFormat(symbol) {
                if (!symbol) return '';
                return symbol.includes('/') ? symbol : `${symbol}/USD`;
            },

            // Normalize for comparison: "BTC/USD" -> "BTC"
            normalize(symbol) {
                if (!symbol) return '';
                return symbol.toUpperCase()
                    .replace(/[-/:].*$/, '')
                    .replace(/USD$|USDT$|USDC$/, '')
                    .trim();
            }
        };

        // Extract balance information from account data (DRY - avoid duplication)
        function extractBalanceInfo(accountData, margin = 0) {
            if (!accountData?.marginSummary?.accountValue) {
                return { total: null, free: null, ratio: null };
            }

            const total = parseFloat(accountData.marginSummary.accountValue);
            const free = total - margin;
            const ratio = total > 0 ? (margin / total) * 100 : 0;

            return { total, free, ratio };
        }

        // UI Elements
        const elements = {
            traderSelect: document.getElementById('trader-select'),
            traderAddress: document.getElementById('trader-address'),
            customAddressContainer: document.getElementById('custom-address-container'),
            moonlanderPrivateKey: document.getElementById('moonlander-private-key'),
            copyBalance: document.getElementById('copy-balance'),
            startButton: document.getElementById('start-button'),
            stopButton: document.getElementById('stop-button'),
            statusDisplay: document.getElementById('status-display'),

            statBalance: document.getElementById('stat-balance'),
            statSyncs: document.getElementById('stat-syncs'),
            statAdded: document.getElementById('stat-added'),
            statRemoved: document.getElementById('stat-removed'),
            statErrors: document.getElementById('stat-errors'),

            traderPositionsBody: document.getElementById('trader-positions-body'),
            userPositionsBody: document.getElementById('user-positions-body'),
            traderPositionCount: document.getElementById('trader-position-count'),
            userPositionCount: document.getElementById('user-position-count'),

            // Balance Info Elements
            balanceUserTotal: document.getElementById('balance-user-total'),
            balanceUserAvailable: document.getElementById('balance-user-available'),
            balanceUserMargin: document.getElementById('balance-user-margin'),
            balanceUserPositionValue: document.getElementById('balance-user-position-value'),
            balanceUserPnl: document.getElementById('balance-user-pnl'),
            balanceUserFree: document.getElementById('balance-user-free'),
            balanceUserRatio: document.getElementById('balance-user-ratio'),
            balanceTraderTotal: document.getElementById('balance-trader-total'),
            balanceTraderAvailable: document.getElementById('balance-trader-available'),
            balanceTraderMargin: document.getElementById('balance-trader-margin'),
            balanceTraderPositionValue: document.getElementById('balance-trader-position-value'),
            balanceTraderPnl: document.getElementById('balance-trader-pnl'),
            balanceTraderRatio: document.getElementById('balance-trader-ratio'),
            balanceScalingFactor: document.getElementById('balance-scaling-factor'),

            actionsContent: document.getElementById('actions-content'),
            activityLog: document.getElementById('activity-log'),
            clearLogBtn: document.getElementById('clear-log-btn')
        };

        // Event listeners
        // Handle trader selection dropdown
        elements.traderSelect.addEventListener('change', (e) => {
            const selectedValue = e.target.value;
            if (selectedValue === 'custom') {
                // Show custom address input
                elements.customAddressContainer.style.display = 'block';
                elements.traderAddress.value = '';
                elements.traderAddress.required = true;
            } else if (selectedValue) {
                // Use preset address
                elements.customAddressContainer.style.display = 'none';
                elements.traderAddress.value = selectedValue;
                elements.traderAddress.required = false;
            } else {
                // No selection
                elements.customAddressContainer.style.display = 'none';
                elements.traderAddress.value = '';
                elements.traderAddress.required = true;
            }
        });

        elements.startButton.addEventListener('click', startMonitoring);
        elements.stopButton.addEventListener('click', stopMonitoring);
        elements.clearLogBtn.addEventListener('click', clearLog);

        // Initialize version display
        document.getElementById('version-display').textContent = `v${VERSION}`;
        document.title = `Position Sync Monitor v${VERSION}`;
        console.log(`üîÑ Position Sync Monitor v${VERSION} (${BUILD_DATE})`);
        console.log(`üìã Features: Dynamic safety buffer, 15% size tolerance, embedded balance info`);

        // Logging
        function log(level, message) {
            const timestamp = new Date().toLocaleTimeString();
            const entry = document.createElement('div');
            entry.className = `log-entry ${level}`;
            entry.innerHTML = `<span class="text-gray-500">[${timestamp}]</span> ${message}`;

            elements.activityLog.appendChild(entry);
            elements.activityLog.scrollTop = elements.activityLog.scrollHeight;

            // Keep only last MAX_LOG_ENTRIES entries
            while (elements.activityLog.children.length > MAX_LOG_ENTRIES) {
                elements.activityLog.removeChild(elements.activityLog.firstChild);
            }
        }

        function clearLog() {
            elements.activityLog.innerHTML = '<div class="log-entry info"><span class="text-gray-500">[Cleared]</span> Log cleared</div>';
        }

        // Update stats display
        function updateStats() {
            elements.statBalance.textContent = `$${stats.balance.toFixed(2)}`;
            elements.statSyncs.textContent = stats.syncs;
            elements.statAdded.textContent = stats.added;
            elements.statRemoved.textContent = stats.removed;
            elements.statErrors.textContent = stats.errors;
        }

        // Render position row with liquidation price, position value, and margin percentage
        function renderPositionRow(pos, totalBalance = null, showPnl = true) {
            const sideClass = (pos.side === 'long' || pos.side === 'buy') ? 'side-long' : 'side-short';
            const sideText = (pos.side === 'long' || pos.side === 'buy') ? 'LONG' : 'SHORT';
            const isLong = pos.side === 'long' || pos.side === 'buy';

            // Use margin from pos if available, otherwise calculate
            const margin = pos.margin !== undefined ? pos.margin : (pos.size * pos.entryPrice) / pos.leverage;

            // Calculate position value at entry price
            const positionValue = pos.size * pos.entryPrice;

            // Calculate liquidation price
            // For LONG: liquidationPrice = entryPrice * (1 - 1/leverage)
            // FOR SHORT: liquidationPrice = entryPrice * (1 + 1/leverage)
            let liquidationPrice = 0;
            if (isLong) {
                liquidationPrice = pos.entryPrice * (1 - (MAINTENANCE_MARGIN_RATIO / pos.leverage));
            } else {
                liquidationPrice = pos.entryPrice * (1 + (MAINTENANCE_MARGIN_RATIO / pos.leverage));
            }

            // Calculate margin percentage if total balance is provided
            let marginPercent = '-';
            if (totalBalance !== null && totalBalance > 0) {
                marginPercent = ((margin / totalBalance) * 100).toFixed(2) + '%';
            }

            // Format PnL display
            const pnl = pos.unrealizedPnl !== undefined ? pos.unrealizedPnl : 0;
            const pnlClass = pnl >= 0 ? 'text-green-400' : 'text-red-400';
            const pnlSign = pnl >= 0 ? '+' : '';
            const pnlDisplay = `<span class="${pnlClass}">${pnlSign}$${pnl.toFixed(2)}</span>`;

            // Format displays
            const stopLossDisplay = pos.stopLoss
                ? `<span class="text-red-400">$${pos.stopLoss.toLocaleString()}</span>`
                : '<span class="text-gray-500">-</span>';
            const takeProfitDisplay = pos.takeProfit
                ? `<span class="text-green-400">$${pos.takeProfit.toLocaleString()}</span>`
                : '<span class="text-gray-500">-</span>';
            const liquidationPriceDisplay = liquidationPrice > 0 ? `<span class="text-orange-400">$${liquidationPrice.toLocaleString()}</span>` : '-';
            const positionValueDisplay = `$${positionValue.toLocaleString()}`;

            return `
                <tr>
                    <td class="font-semibold">${pos.symbol}</td>
                    <td><span class="${sideClass}">${sideText}</span></td>
                    <td class="text-right font-mono">${pos.size.toFixed(4)}</td>
                    <td class="text-right font-mono">$${pos.entryPrice.toLocaleString()}</td>
                    ${showPnl ? `<td class="text-right font-mono">${pnlDisplay}</td>` : ''}
                    <td class="text-right font-mono">${stopLossDisplay}</td>
                    <td class="text-right font-mono">${takeProfitDisplay}</td>
                    <td class="text-right font-mono">${liquidationPriceDisplay}</td>
                    <td class="text-right">${pos.leverage.toFixed(1)}x</td>
                    <td class="text-right font-mono">$${margin.toFixed(2)}</td>
                    <td class="text-right font-mono text-purple-400">${positionValueDisplay}</td>
                    <td class="text-right font-mono text-blue-400">${marginPercent}</td>
                </tr>
            `;
        }

        // Fetch trader's last trade timestamp from user fills
        async function fetchLastTradeTimestamp(traderAddress) {
            try {
                const response = await fetch(`${monitorExchange.urls.api.public}/info`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        type: 'userFills',
                        user: traderAddress,
                    }),
                });

                const fills = await response.json();

                // Get the most recent fill timestamp
                if (fills && fills.length > 0) {
                    // Fills are sorted by time, most recent first
                    return fills[0].time;
                }

                return null;
            } catch (error) {
                console.error('Failed to fetch last trade timestamp:', error);
                return null;
            }
        }

        // Fetch trader positions and account data (reusing logic from positionSyncer.js:225-254)
        // Fetch trader's open orders (for stop loss and take profit)
        async function fetchTraderOrders(traderAddress) {
            try {
                const response = await fetch(`${monitorExchange.urls.api.public}/info`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        type: 'frontendOpenOrders',
                        user: traderAddress,
                    }),
                });

                const orders = await response.json();
                return orders || [];
            } catch (error) {
                log('warning', `Failed to fetch trader orders: ${error.message}`);
                return [];
            }
        }

        async function fetchTraderPositions(traderAddress) {
            try {
                // Fetch positions via Hyperliquid API (same as positionSyncer.js)
                const response = await fetch(`${monitorExchange.urls.api.public}/info`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        type: 'clearinghouseState',
                        user: traderAddress,
                    }),
                });

                const data = await response.json();

                // Fetch open orders to get stop loss and take profit levels
                const orders = await fetchTraderOrders(traderAddress);

                // Convert to standard format
                const positions = data.assetPositions
                    .filter((pos) => Math.abs(pos.position.szi) > 0)
                    .map((pos) => {
                        const symbol = pos.position.coin;
                        const side = parseFloat(pos.position.szi) > 0 ? 'long' : 'short';
                        const size = Math.abs(parseFloat(pos.position.szi));

                        // Find stop loss and take profit from trigger orders
                        let stopLoss = null;
                        let takeProfit = null;

                        // Filter trigger orders for this position with robust matching
                        const positionOrders = orders.filter(order => {
                            // Must be same symbol
                            if (order.coin !== symbol) return false;

                            // Must be trigger order
                            if (!order.isTrigger) return false;

                            // Must have size (origSz or sz)
                            const orderSize = parseFloat(order.origSz || order.sz || 0);
                            if (orderSize === 0) return false;

                            // Size should be close to position size (allow 1% tolerance for partial fills)
                            const sizeDiff = Math.abs(orderSize - size) / size;
                            if (sizeDiff > 0.01) return false;

                            // Must be closing order (opposite side of position)
                            // For LONG position, closing orders are sell ('A' = Ask)
                            // For SHORT position, closing orders are buy ('B' = Bid)
                            if (side === 'long' && order.side !== 'A') return false;
                            if (side === 'short' && order.side !== 'B') return false;

                            return true;
                        }).sort((a, b) => {
                            // Sort by timestamp descending (most recent first)
                            // Use oid (order ID) as proxy for timestamp - higher oid = newer order
                            return (b.oid || 0) - (a.oid || 0);
                        });

                        // Track which type we've found to ensure we only use the latest of each type
                        let foundStopLoss = false;
                        let foundTakeProfit = false;

                        for (const order of positionOrders) {
                            const triggerPrice = parseFloat(order.triggerPx);
                            const entryPrice = parseFloat(pos.position.entryPx);

                            // Parse trigger condition - it comes as "Price below X" or "Price above X"
                            const isBelowTrigger = order.triggerCondition.toLowerCase().includes('below');
                            const isAboveTrigger = order.triggerCondition.toLowerCase().includes('above');

                            // For LONG positions:
                            // - Stop loss = trigger below entry price (exit when price drops)
                            // - Take profit = trigger above entry price (exit when price rises)
                            if (side === 'long') {
                                if (isBelowTrigger && triggerPrice < entryPrice && !foundStopLoss) {
                                    stopLoss = triggerPrice;
                                    foundStopLoss = true;
                                } else if (isAboveTrigger && triggerPrice > entryPrice && !foundTakeProfit) {
                                    takeProfit = triggerPrice;
                                    foundTakeProfit = true;
                                }
                            }
                            // For SHORT positions:
                            // - Stop loss = trigger above entry price (exit when price rises)
                            // - Take profit = trigger below entry price (exit when price drops)
                            else if (side === 'short') {
                                if (isAboveTrigger && triggerPrice > entryPrice && !foundStopLoss) {
                                    stopLoss = triggerPrice;
                                    foundStopLoss = true;
                                } else if (isBelowTrigger && triggerPrice < entryPrice && !foundTakeProfit) {
                                    takeProfit = triggerPrice;
                                    foundTakeProfit = true;
                                }
                            }

                            // Stop iterating once we've found both SL and TP
                            if (foundStopLoss && foundTakeProfit) break;
                        }

                        return {
                            symbol,
                            side,
                            size,
                            entryPrice: parseFloat(pos.position.entryPx),
                            leverage: parseFloat(pos.position.leverage.value),
                            unrealizedPnl: parseFloat(pos.position.unrealizedPnl),
                            margin: parseFloat(pos.position.marginUsed),
                            stopLoss,
                            takeProfit,
                        };
                    });

                // Return both positions and full account data for balance calculations
                return { positions, accountData: data };
            } catch (error) {
                log('error', `Failed to fetch trader positions: ${error.message}`);
                stats.errors++;
                return { positions: [], accountData: null };
            }
        }

        // Moonlander configuration
        const MOONLANDER_CONFIG = {
            rpcUrl: 'https://evm.cronos.org',
            diamondAddress: '0xE6F6351fb66f3a35313fEEFF9116698665FBEeC9',
            pairAddresses: {
                'BTC/USD': '0x062E66477Faf219F25D27dCED647BF57C3107d52',
                'ETH/USD': '0xe44Fd7fCb2b1581822D0c862B68222998a0c299a',
                'SOL/USD': '0xc9DE0F3e08162312528FF72559db82590b481800',
                'CRO/USD': '0x5C7F8A570d578ED84E63fdFA7b1eE72dEae1AE23',

                // Layer 1 chains
                'AVAX/USD': '0x8d58088D4E8Ffe75A8b6357ba5ff17B93B912640',
                'DOT/USD': '0x994047FE66406CbD646cd85B990E11D7F5dB8fC7',
                'ATOM/USD': '0xB888d8Dd1733d72681b30c00ee76BDE93ae7aa93', // Cosmos
                'NEAR/USD': '0xAFE470AE215e48c144c7158EAe3CcF0C451cb0CB',
                'ADA/USD': '0x0e517979C2c1c1522ddB0c73905e0D39b3F990c0',
                'ALGO/USD': '0x2fEfe47989214c2e74A6319076c138d395681407',
                'TON/USD': '0x8d96EA3c7F7B7A824e2C8277495007c7Fbd769ea',
                'SUI/USD': '0x81710203A7FC16797aC9899228a87fd622df9706',
                'HBAR/USD': '0xe0C7226a58f54db71eDc6289Ba2dc80349B41974',

                // Major altcoins
                'LINK/USD': '0xBc6f24649CCd67eC42342AccdCECCB2eFA27c9d9',
                'UNI/USD': '0x16aD43896f7C47a5d9Ee546c44A22205738B329c',
                'AAVE/USD': '0xE657b115bc45c0786274c824f83e3e02CE809185',
                'XRP/USD': '0xb9Ce0dd29C91E02d4620F57a66700Fc5e41d6D15',
                'DOGE/USD': '0x1a8E39ae59e5556B56b76fCBA98d22c9ae557396',
                'LTC/USD': '0x9d97Be214b68C7051215BB61059B4e299Cd792c3',

                // Leveraged pairs (500x) - VERIFIED from successful mainnet transaction
                '500BTC/USD': '0xBAd4ccc91EF0dfFfbCAb1402C519601fbAf244EF',
            }
        };

        // TradingReaderFacet ABI (minimal - only getPositionsV2)
        const TRADING_READER_ABI = [
            {
                "inputs": [
                    {"internalType": "address", "name": "user", "type": "address"},
                    {"internalType": "address", "name": "marginToken", "type": "address"}
                ],
                "name": "getPositionsV2",
                "outputs": [{
                    "components": [
                        {"internalType": "bytes32", "name": "positionHash", "type": "bytes32"},
                        {"internalType": "string", "name": "pair", "type": "string"},
                        {"internalType": "address", "name": "pairBase", "type": "address"},
                        {"internalType": "address", "name": "marginToken", "type": "address"},
                        {"internalType": "bool", "name": "isLong", "type": "bool"},
                        {"internalType": "uint96", "name": "margin", "type": "uint96"},
                        {"internalType": "uint128", "name": "qty", "type": "uint128"},
                        {"internalType": "uint128", "name": "entryPrice", "type": "uint128"},
                        {"internalType": "uint128", "name": "stopLoss", "type": "uint128"},
                        {"internalType": "uint128", "name": "takeProfit", "type": "uint128"},
                        {"internalType": "int256", "name": "fundingFee", "type": "int256"},
                        {"internalType": "uint40", "name": "timestamp", "type": "uint40"}
                    ],
                    "internalType": "struct ITradingReader.PositionWithPairInfo[]",
                    "name": "",
                    "type": "tuple[]"
                }],
                "stateMutability": "view",
                "type": "function"
            }
        ];

        // Fetch Moonlander positions (with contract interaction)
        async function fetchMoonlanderPositions(userAddress) {
            try {
                log('info', `üìç Moonlander wallet: ${userAddress.slice(0, 6)}...${userAddress.slice(-4)}`);

                // Create provider and contract
                const provider = new ethers.JsonRpcProvider(MOONLANDER_CONFIG.rpcUrl);
                const tradingReader = new ethers.Contract(
                    MOONLANDER_CONFIG.diamondAddress,
                    TRADING_READER_ABI,
                    provider
                );

                // Fetch positions (ZeroAddress = all margin tokens)
                const positions = await tradingReader.getPositionsV2(userAddress, ethers.ZeroAddress);

                // Create address to symbol mapping
                const addressToSymbol = {};
                for (const [symbol, address] of Object.entries(MOONLANDER_CONFIG.pairAddresses)) {
                    addressToSymbol[address.toLowerCase()] = symbol;
                }

                // Parse positions
                const parsedPositions = positions.map(pos => {
                    const pairAddress = pos.pairBase.toLowerCase();
                    const symbol = addressToSymbol[pairAddress] || pos.pairBase;

                    const size = Number(pos.qty) / QTY_DIVISOR;
                    const entryPrice = Number(pos.entryPrice) / PRICE_DIVISOR;
                    const margin = Number(pos.margin) / USDC_DIVISOR;

                    const positionValue = size * entryPrice;
                    const leverage = margin > 0 ? positionValue / margin : 0;

                    return {
                        tradeHash: pos.positionHash,
                        symbol,
                        pairAddress: pos.pairBase,
                        side: pos.isLong ? 'long' : 'short',
                        size,
                        entryPrice,
                        margin,
                        leverage,
                        stopLoss: Number(pos.stopLoss) / PRICE_DIVISOR,
                        takeProfit: Number(pos.takeProfit) / PRICE_DIVISOR,
                        fundingFee: Number(pos.fundingFee) / USDC_DIVISOR,
                        openTimestamp: Number(pos.timestamp)
                    };
                });

                if (parsedPositions.length > 0) {
                    log('success', `Found ${parsedPositions.length} Moonlander position(s)`);
                }

                return parsedPositions;
            } catch (error) {
                log('error', `Failed to fetch Moonlander positions: ${error.message}`);
                return [];
            }
        }

        // Fetch current prices from Hyperliquid and enrich positions with PnL
        async function enrichPositionsWithPnL(positions) {
            if (!positions || positions.length === 0) {
                return positions;
            }

            try {
                // Fetch current prices for all symbols via Hyperliquid meta endpoint
                const response = await fetch(`${HYPERLIQUID_API_URL}/info`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ type: 'allMids' })
                });

                const allMids = await response.json();

                // Enrich each position with current price and calculated PnL
                const enrichedPositions = positions.map(pos => {
                    // Convert Moonlander symbol format (BTC/USD) to Hyperliquid format (BTC)
                    const hyperliquidSymbol = pos.symbol.replace('/USD', '');
                    const currentPrice = parseFloat(allMids[hyperliquidSymbol]);

                    if (!currentPrice || isNaN(currentPrice)) {
                        console.warn(`‚ö†Ô∏è  ${pos.symbol}: Price not found, PnL = $0`);
                        return { ...pos, unrealizedPnl: 0 };
                    }

                    // Calculate PnL: (currentPrice - entryPrice) * size for LONG
                    //                (entryPrice - currentPrice) * size for SHORT
                    const isLong = pos.side === 'long' || pos.side === 'buy';
                    const priceDiff = isLong
                        ? (currentPrice - pos.entryPrice)
                        : (pos.entryPrice - currentPrice);
                    const unrealizedPnl = priceDiff * pos.size;

                    return {
                        ...pos,
                        currentPrice,
                        unrealizedPnl
                    };
                });

                return enrichedPositions;
            } catch (error) {
                console.error('‚ùå Failed to fetch prices for PnL calculation:', error.message);
                return positions;
            }
        }

        // TradingPortalFacet ABI (minimal - open and close trades)
        const TRADING_PORTAL_ABI = [
            {
                "inputs": [
                    {
                        "components": [
                            {"internalType": "address", "name": "pairBase", "type": "address"},
                            {"internalType": "bool", "name": "isLong", "type": "bool"},
                            {"internalType": "address", "name": "tokenIn", "type": "address"},
                            {"internalType": "uint96", "name": "amountIn", "type": "uint96"},
                            {"internalType": "uint128", "name": "qty", "type": "uint128"},
                            {"internalType": "uint128", "name": "price", "type": "uint128"},
                            {"internalType": "uint128", "name": "stopLoss", "type": "uint128"},
                            {"internalType": "uint128", "name": "takeProfit", "type": "uint128"},
                            {"internalType": "uint24", "name": "broker", "type": "uint24"}
                        ],
                        "internalType": "struct IBook.OpenDataInput",
                        "name": "data",
                        "type": "tuple"
                    },
                    {"internalType": "bytes[]", "name": "priceUpdateData", "type": "bytes[]"}
                ],
                "name": "openMarketTradeWithPyth",
                "outputs": [{"internalType": "bytes32", "name": "tradeHash", "type": "bytes32"}],
                "stateMutability": "payable",
                "type": "function"
            },
            {
                "inputs": [{"internalType": "bytes32", "name": "tradeHash", "type": "bytes32"}],
                "name": "closeTrade",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            }
        ];

        const USDC_ADDRESS = '0xc21223249CA28397B4B6541dfFaEcC539BfF0c59'; // Cronos mainnet
        const ERC20_ABI = [
            'function approve(address spender, uint256 amount) returns (bool)',
            'function allowance(address owner, address spender) view returns (uint256)',
            'function balanceOf(address account) view returns (uint256)',
            'function decimals() view returns (uint8)'
        ];

        // Fetch Moonlander wallet total equity (free balance + position value)
        async function fetchMoonlanderBalance(walletAddress) {
            try {
                const provider = new ethers.JsonRpcProvider(MOONLANDER_CONFIG.rpcUrl);
                const usdcContract = new ethers.Contract(USDC_ADDRESS, ERC20_ABI, provider);

                // Get free USDC balance
                const [balance, decimals] = await Promise.all([
                    usdcContract.balanceOf(walletAddress),
                    usdcContract.decimals()
                ]);

                const freeBalance = Number(ethers.formatUnits(balance, decimals));

                // Get current positions with PnL enrichment
                const positions = await fetchMoonlanderPositions(walletAddress);
                const enrichedPositions = await enrichPositionsWithPnL(positions);

                const positionsMargin = enrichedPositions.reduce((sum, pos) => sum + pos.margin, 0);
                const positionsPnl = enrichedPositions.reduce((sum, pos) => sum + (pos.unrealizedPnl || 0), 0);

                // Total equity = free balance + positions margin + unrealized PnL
                const totalEquity = freeBalance + positionsMargin + positionsPnl;

                // Enforce minimum equity
                if (totalEquity < MIN_COPY_BALANCE) {
                    log('warning', `‚ö†Ô∏è  Total equity ($${totalEquity.toFixed(2)}) is below minimum $${MIN_COPY_BALANCE}`);
                }

                const pnlSign = positionsPnl >= 0 ? '+' : '';
                log('success', `üí∞ Free: $${freeBalance.toFixed(2)} + Margin: $${positionsMargin.toFixed(2)} ${pnlSign}$${positionsPnl.toFixed(2)} PnL = Total: $${totalEquity.toFixed(2)} USDC`);

                // Return object with both free balance and total equity
                return {
                    freeBalance,
                    totalEquity,
                    positionsValue: positionsMargin
                };
            } catch (error) {
                log('error', `Failed to fetch balance: ${error.message}`);
                return {
                    freeBalance: MIN_COPY_BALANCE,
                    totalEquity: MIN_COPY_BALANCE,
                    positionsValue: 0
                };
            }
        }

        // Execute copy trade on Moonlander
        async function executeCopyTrade(position, action) {
            try {
                const moonlanderKey = elements.moonlanderPrivateKey.value;

                if (action === 'open') {
                    log('info', `üåô Opening Moonlander: ${position.symbol} ${position.side.toUpperCase()} ${position.size.toFixed(4)} @ market - Margin: $${position.margin.toFixed(2)}`);

                    // Create signer
                    const provider = new ethers.JsonRpcProvider(MOONLANDER_CONFIG.rpcUrl);
                    const signer = new ethers.Wallet(moonlanderKey, provider);

                    // Convert symbol: "BTC" -> "BTC/USD"
                    const moonlanderSymbol = SymbolUtils.toMoonlanderFormat(position.symbol);

                    // Get pair address
                    const pairAddress = MOONLANDER_CONFIG.pairAddresses[moonlanderSymbol];
                    if (!pairAddress) {
                        throw new Error(`Pair ${moonlanderSymbol} not found in config`);
                    }

                    // Fetch Pyth price
                    const pythPrice = await fetchPythPrice(moonlanderSymbol);

                    // Calculate parameters
                    const isLong = position.side === 'long' || position.side === 'buy';
                    const amountIn = ethers.parseUnits(position.margin.toFixed(DECIMALS_USDC), DECIMALS_USDC);
                    const qtyWei = ethers.parseUnits(position.size.toFixed(DECIMALS_QTY), DECIMALS_QTY);
                    const acceptablePrice = calculateAcceptablePrice(pythPrice.price, isLong);

                    // Use stop loss and take profit from Hyperliquid position if available
                    let stopLossPrice;
                    let takeProfitPrice;

                    if (position.stopLoss) {
                        // Convert from decimal price to BigInt wei format (18 decimals)
                        stopLossPrice = ethers.parseUnits(position.stopLoss.toFixed(DECIMALS_PRICE), DECIMALS_PRICE);
                        log('info', `  üìç Using trader's stop loss: $${position.stopLoss.toFixed(2)}`);
                    } else {
                        // Fallback to default percentages
                        stopLossPrice = isLong
                            ? (pythPrice.price * BigInt(STOP_LOSS_PERCENT_LONG)) / 100n
                            : (pythPrice.price * BigInt(STOP_LOSS_PERCENT_SHORT)) / 100n;
                        log('info', `  ‚ö†Ô∏è  No stop loss from trader, using default`);
                    }

                    if (position.takeProfit) {
                        // Convert from decimal price to BigInt wei format (18 decimals)
                        takeProfitPrice = ethers.parseUnits(position.takeProfit.toFixed(DECIMALS_PRICE), DECIMALS_PRICE);
                        log('info', `  üéØ Using trader's take profit: $${position.takeProfit.toFixed(2)}`);
                    } else {
                        // Fallback to default percentages
                        takeProfitPrice = isLong
                            ? (pythPrice.price * BigInt(TAKE_PROFIT_PERCENT_LONG)) / 100n
                            : (pythPrice.price * BigInt(TAKE_PROFIT_PERCENT_SHORT)) / 100n;
                        log('info', `  ‚ö†Ô∏è  No take profit from trader, using default`);
                    }

                    // Debug logging
                    console.log(`  üìä Trade Parameters:`);
                    console.log(`     Position: ${position.symbol} ${isLong ? 'LONG' : 'SHORT'}`);
                    console.log(`     Size: ${position.size} (${qtyWei.toString()} wei)`);
                    console.log(`     Margin: $${position.margin.toFixed(2)} (${amountIn.toString()} wei)`);
                    console.log(`     Pyth Price: ${pythPrice.price.toString()}`);
                    console.log(`     Acceptable Price: ${acceptablePrice.toString()}`);
                    console.log(`     Stop Loss: ${stopLossPrice.toString()}`);
                    console.log(`     Take Profit: ${takeProfitPrice.toString()}`);
                    console.log(`     Pair Address: ${pairAddress}`);

                    // Approve USDC if needed
                    const usdcContract = new ethers.Contract(USDC_ADDRESS, ERC20_ABI, signer);
                    const allowance = await usdcContract.allowance(signer.address, MOONLANDER_CONFIG.diamondAddress);
                    if (allowance < amountIn) {
                        log('info', `  Approving USDC...`);
                        const approveTx = await usdcContract.approve(MOONLANDER_CONFIG.diamondAddress, ethers.MaxUint256);
                        await approveTx.wait();
                        log('success', `  USDC approved`);
                    }

                    // Open trade
                    const tradingPortal = new ethers.Contract(MOONLANDER_CONFIG.diamondAddress, TRADING_PORTAL_ABI, signer);
                    const tx = await tradingPortal.openMarketTradeWithPyth(
                        {
                            pairBase: pairAddress,
                            isLong,
                            tokenIn: USDC_ADDRESS,
                            amountIn,
                            qty: qtyWei,
                            price: acceptablePrice,
                            stopLoss: stopLossPrice,
                            takeProfit: takeProfitPrice,
                            broker: DEFAULT_BROKER_ID
                        },
                        pythPrice.pythUpdateData,
                        {
                            gasLimit: GAS_LIMIT_OPEN_TRADE,
                            value: ethers.parseEther(PYTH_UPDATE_FEE)
                        }
                    );

                    log('info', `  ‚è≥ Waiting for confirmation...`);
                    const receipt = await tx.wait();

                    if (receipt.status === 0) {
                        throw new Error(`Transaction reverted on-chain: ${receipt.hash}`);
                    }

                    log('success', `  ‚úÖ Trade opened: ${receipt.hash}`);

                } else if (action === 'close') {
                    log('info', `üåô Closing Moonlander: ${position.symbol}`);

                    const provider = new ethers.JsonRpcProvider(MOONLANDER_CONFIG.rpcUrl);
                    const signer = new ethers.Wallet(moonlanderKey, provider);
                    const tradingPortal = new ethers.Contract(MOONLANDER_CONFIG.diamondAddress, TRADING_PORTAL_ABI, signer);

                    const tx = await tradingPortal.closeTrade(position.tradeHash, { gasLimit: GAS_LIMIT_CLOSE_TRADE });

                    log('info', `  ‚è≥ Waiting for confirmation...`);
                    const receipt = await tx.wait();
                    log('success', `  ‚úÖ Trade closed: ${receipt.hash}`);
                }

            } catch (error) {
                console.error('  üî¥ Full error:', error);
                if (error.transaction) {
                    console.error('  Transaction:', error.transaction);
                }
                if (error.receipt) {
                    console.error('  Receipt:', error.receipt);
                }
                if (error.reason) {
                    log('error', `‚ùå Execution error: ${error.reason}`);
                } else {
                    log('error', `‚ùå Execution error: ${error.message}`);
                }
                stats.errors++;
            }
        }

        // Fetch Pyth price data
        async function fetchPythPrice(symbol) {
            const pythPriceIds = {
        // Major Crypto
        'BTC/USD': '0xe62df6c8b4a85fe1a67db44dc12de5db330f7ac66b72dc658afedf0f4a415b43',
        'ETH/USD': '0xff61491a931112ddf1bd8147cd1b641375f79f5825126d665480874634fd0ace',
        'SOL/USD': '0xef0d8b6fda2ceba41da15d4095d1da392a0d2f8ed0c6c7bc0f4cfac8c280b56d',
        'CRO/USD': '0x23199c2bcb1303f667e733b9934db9eca5991e765b45f5ed18bc4b231415f2fe',

        // Layer 1 Chains
        'AVAX/USD': '0x93da3352f9f1d105fdfe4971cfa80e9dd777bfc5d0f683ebb6e1294b92137bb7',
        'DOT/USD': '0xca3eed9b267293f6595901c734c7525ce8ef49adafe8284606ceb307afa2ca5b',
        'ATOM/USD': '0xb00b60f88b03a6a625a8d1c048c3f66653edf217439983d037e7222c4e612819',
        'NEAR/USD': '0xc415de8d2eba7db216527dff4b60e8f3a5311c740dadb233e13e12547e226750',
                'ADA/USD': '0x2a01deaec9e51a579277b34b122399984d0bbf57e2458a7e42fecd2829867a0d',
                'ALGO/USD': '0xfa17ceaf30d19ba51112fdcc750cc83454776f47fb0112e4af07f15f4bb1ebc0',
                'TON/USD': '0x8963217838ab4cf5cadc172203c1f0b763fbaa45f346d8ee50ba994bbcac3026',
                'SUI/USD': '0x23d7315113f5b1d3ba7a83604c44b94d79f4fd69af77f804fc7f920a6dc65744',
                'HBAR/USD': '0x8d49e2d0c97f0b0c88e3e30d0f37c2b96d52d84a08eee08ab1f8e8b7f2f9a76a',

                // Major Altcoins
                'LINK/USD': '0x8ac0c70fff57e9aefdf5edf44b51d62c2d433653cbb2cf5cc06bb115af04d221',
                'UNI/USD': '0x78d185a741d07edb3412b09008b7c5cfb9bbbd7d568bf00ba737b456ba171501',
                'AAVE/USD': '0x2b9ab1e972a281585084148ba1389800799bd4be63b957507db1349314e47445',
                'XRP/USD': '0xec5d399846a9209f3fe5881d70aae9268c94339ff9817e8d18ff19fa05eea1c8',
                'DOGE/USD': '0xdcef50dd0a4cd2dcc17e45df1676dcb336a11a61c69df7a0299b0150c672d25c',
                'SHIB/USD': '0xf0d57deca57b3da2fe63a493f4c25925fdfd8edf834b20f93e1f84dbd1504d4a',
                'PEPE/USD': '0xd69731a2e74ac1ce884fc3890f7ee324b6deb66147055249568869ed700882e4',
                'LTC/USD': '0x6e3f3fa8253588df9326580180233eb791e03b443a3ba7a1d892e73874e19a54',
                'BCH/USD': '0x3dd2b63686a450ec7290df3a1e0b583c0481f651351edfa7636f39aed55cf8a3',
                'ETC/USD': '0x7f5cc8d963fc5b3d2ae41fe5685ada89fd4f14b435f8050f28c7fd409f40c2d8',

                // Layer 2 & Scaling
                'ARB/USD': '0x3fa4252848f9f0a1480be62745a4629d9eb1322aebab8a791e344b3b9c1adcf5',
                'POL/USD': '0xffd11c5a1cfd42f80afb2df4d9f264c15f956d68153335374ec10722edd70472',

                // AI & Gaming
                'FET/USD': '0xb98e7ae8af2d298d2651eb21ab5b8b5738212e13efb43bd0dfbce7a74ba4b5d0',
                'TAO/USD': '0x8a646b51e31085f85f7feda4813d7a30ebf8e08d3e0e96a8b3c4ef6f2f6f2e64',
                'RAY/USD': '0x91568baa8beb53db23eb3fb7f22c6e8b1b82d1e1c7e4c82e0c8be7d2e95c3e3e',
                'SAND/USD': '0xabf2e3f5f2f7e75c9e2e3f5f2f7e75c9e2e3f5f2f7e75c9e2e3f5f2f7e75c9e2',
            };

            const priceId = pythPriceIds[symbol];
            if (!priceId) {
                throw new Error(`Pyth price ID not found for ${symbol}`);
            }

            const response = await fetch(`https://hermes.pyth.network/api/latest_vaas?ids[]=${priceId}`);
            const data = await response.json();

            if (!data || data.length === 0) {
                throw new Error(`No Pyth data returned for ${symbol}`);
            }

            // The response is an array of base64-encoded VAAs
            const pythUpdateData = data.map(vaaBase64 => {
                try {
                    // Decode base64 to binary string
                    const binaryString = atob(vaaBase64);
                    let hex = '0x';
                    for (let i = 0; i < binaryString.length; i++) {
                        hex += ('0' + binaryString.charCodeAt(i).toString(16)).slice(-2);
                    }
                    return hex;
                } catch (error) {
                    console.error('Failed to decode VAA:', error);
                    throw new Error(`Failed to decode Pyth VAA data: ${error.message}`);
                }
            });

            // Fetch current price separately from latest_price_feeds endpoint
            const priceResponse = await fetch(`https://hermes.pyth.network/api/latest_price_feeds?ids[]=${priceId}`);
            const priceData = await priceResponse.json();

            if (!priceData || priceData.length === 0) {
                throw new Error(`No price data returned for ${symbol}`);
            }

            const priceInfo = priceData[0].price;
            const price = BigInt(priceInfo.price) * (10n ** BigInt(18 + priceInfo.expo));

            return {
                price,
                pythUpdateData
            };
        }

        // Calculate acceptable price with slippage
        function calculateAcceptablePrice(currentPrice, isLong, slippagePercent = DEFAULT_SLIPPAGE_PERCENT) {
            const multiplier = isLong ? 100 + slippagePercent : 100 - slippagePercent;
            return (currentPrice * BigInt(multiplier)) / 100n;
        }

        // Update positions display
        function updatePositions(traderPositions, userPositions, traderAccountData = null, userAccountData = null) {
            // Calculate total balances for margin percentage
            const traderTotalBalance = traderAccountData?.marginSummary?.accountValue
                ? parseFloat(traderAccountData.marginSummary.accountValue)
                : null;
            const userTotalBalance = userAccountData?.marginSummary?.accountValue
                ? parseFloat(userAccountData.marginSummary.accountValue)
                : null;

            // Trader positions
            if (traderPositions.length > 0) {
                elements.traderPositionCount.textContent = `${traderPositions.length} position${traderPositions.length > 1 ? 's' : ''}`;
                elements.traderPositionsBody.innerHTML = traderPositions.map(pos => renderPositionRow(pos, traderTotalBalance)).join('');
            } else {
                elements.traderPositionCount.textContent = '0 positions';
                elements.traderPositionsBody.innerHTML = '<tr><td colspan="11" class="text-center text-gray-500 py-4">No positions</td></tr>';
            }

            // User positions (with PnL calculated from Hyperliquid prices)
            if (userPositions.length > 0) {
                elements.userPositionCount.textContent = `${userPositions.length} position${userPositions.length > 1 ? 's' : ''}`;
                elements.userPositionsBody.innerHTML = userPositions.map(pos => renderPositionRow(pos, userTotalBalance, true)).join('');
            } else {
                elements.userPositionCount.textContent = '0 positions';
                elements.userPositionsBody.innerHTML = '<tr><td colspan="12" class="text-center text-gray-500 py-4">No positions (execution via backend)</td></tr>';
            }
        }

        // Calculate and display actions
        function updateActions(traderPositions) {
            if (traderPositions.length === 0) {
                elements.actionsContent.innerHTML = '<div class="text-center text-green-400 py-4">‚úÖ No trader positions</div>';
                return;
            }

            let html = '<div class="bg-blue-900/20 border border-blue-500/30 rounded p-3">';
            html += '<div class="text-sm font-semibold text-blue-400 mb-2">‚ÑπÔ∏è Detected Positions</div>';
            traderPositions.forEach(pos => {
                const margin = (pos.size * pos.entryPrice) / pos.leverage;
                html += `<div class="text-xs text-gray-300 mb-1">‚Ä¢ ${pos.symbol}: ${pos.side.toUpperCase()} ${pos.size} @ $${pos.entryPrice.toLocaleString()} - Margin: $${margin.toFixed(2)}</div>`;
            });
            html += '</div>';

            elements.actionsContent.innerHTML = html;
        }

        // Calculate target positions (from positionCalculator.js)
        function calculateTargetPositions(traderPositions, copyBalance, traderAccountData = null, userAccountData = null) {
            if (!traderPositions || traderPositions.length === 0) return [];

            // Calculate trader's total margin from their actual positions (same as positionCalculator.js)
            const traderTotalMargin = traderPositions.reduce((sum, pos) => {
                return sum + pos.margin; // Use actual margin from API
            }, 0);

            // Use full safety buffer (100%) to allow users to maximize smaller balances
            // Users can now use their entire balance regardless of trader's margin ratio
            let dynamicSafetyBuffer = SAFETY_BUFFER_PERCENT; // 100% - full balance available

            if (traderAccountData) {
                const traderTotalBalance = parseFloat(traderAccountData.marginSummary.accountValue);
                const traderMarginRatio = traderTotalBalance > 0 ? traderTotalMargin / traderTotalBalance : 0;

                console.log(`üìä Trader margin ratio: ${(traderMarginRatio * 100).toFixed(2)}% ($${traderTotalMargin.toFixed(2)} / $${traderTotalBalance.toFixed(2)})`);
                console.log(`üìä User safety buffer: ${(dynamicSafetyBuffer * 100).toFixed(2)}% (full balance available)`);
            }

            // Scale down using dynamic safety buffer for margin
            // Cap at maximum scaling factor - never scale up beyond trader's size
            let scalingFactor = traderTotalMargin > 0 ? (copyBalance * dynamicSafetyBuffer) / traderTotalMargin : 0;
            if (scalingFactor > MAX_SCALING_FACTOR) {
                scalingFactor = MAX_SCALING_FACTOR;
                console.log(`‚ö†Ô∏è  Scaling capped at ${(MAX_SCALING_FACTOR * 100).toFixed(0)}% (user has more capital than trader)`);
            }

            console.log(`Scaling factor: ${(scalingFactor * 100).toFixed(2)}% | Trader margin: $${traderTotalMargin.toFixed(2)} | User balance: $${copyBalance.toFixed(2)}`);

            const scaledPositions = traderPositions.map(pos => {
                // Use actual margin from API (same as positionCalculator.js logic)
                const traderMargin = pos.margin;
                const copyMargin = traderMargin * scalingFactor;
                const copySize = (copyMargin * pos.leverage) / pos.entryPrice;

                // Ensure copy size never exceeds trader's size (cap at 100% per position)
                const finalSize = Math.min(copySize, pos.size);
                const finalMargin = Math.min(copyMargin, traderMargin);

                return {
                    symbol: pos.symbol,
                    side: pos.side,
                    size: finalSize,
                    entryPrice: pos.entryPrice,
                    leverage: pos.leverage,
                    margin: finalMargin,
                    stopLoss: pos.stopLoss,
                    takeProfit: pos.takeProfit
                };
            });

            // Filter out positions below minimum margin (not position value, since we use leverage)
            const skippedPositions = [];
            const filteredPositions = scaledPositions.filter(pos => {
                const positionValue = pos.size * pos.entryPrice;
                const isValid = pos.margin >= MIN_POSITION_VALUE;
                if (!isValid) {
                    skippedPositions.push({
                        symbol: pos.symbol,
                        side: pos.side,
                        margin: pos.margin,
                        positionValue: positionValue,
                        leverage: pos.leverage
                    });
                }
                return isValid;
            });

            // Log skipped positions to activity panel
            if (skippedPositions.length > 0) {
                log('warning', `‚è≠Ô∏è  Skipped ${skippedPositions.length} small position${skippedPositions.length > 1 ? 's' : ''} (below $${MIN_POSITION_VALUE} margin minimum):`);
                skippedPositions.forEach(pos => {
                    log('info', `   ‚Ä¢ ${pos.symbol} ${pos.side.toUpperCase()}: Margin $${pos.margin.toFixed(2)} (Value: $${pos.positionValue.toFixed(2)}, ${pos.leverage}x leverage)`);
                });
            }

            // Update balance info display if account data is provided
            if (traderAccountData && userAccountData) {
                updateBalanceInfo(traderAccountData, userAccountData, traderTotalMargin, copyBalance, dynamicSafetyBuffer, scalingFactor);
            }

            return filteredPositions;
        }

        // Update balance info display
        function updateBalanceInfo(traderAccountData, userAccountData, traderTotalMargin, userBalance, dynamicSafetyBuffer, scalingFactor) {
            // Trader balance info
            const traderTotal = parseFloat(traderAccountData.marginSummary.accountValue);
            const traderAvailable = traderTotal - traderTotalMargin;
            const traderRatio = traderTotal > 0 ? (traderTotalMargin / traderTotal) * 100 : 0;

            // Calculate trader total position value and PnL
            const traderPositionValue = lastTraderPositions.reduce((sum, pos) => sum + (pos.size * pos.entryPrice), 0);
            const traderTotalPnl = lastTraderPositions.reduce((sum, pos) => sum + (pos.unrealizedPnl || 0), 0);
            const traderPnlClass = traderTotalPnl >= 0 ? 'text-green-400' : 'text-red-400';

            elements.balanceTraderTotal.textContent = `$${traderTotal.toFixed(2)}`;
            elements.balanceTraderAvailable.textContent = `$${traderAvailable.toFixed(2)}`;
            elements.balanceTraderMargin.textContent = `$${traderTotalMargin.toFixed(2)}`;
            elements.balanceTraderPositionValue.textContent = `$${traderPositionValue.toFixed(2)}`;
            elements.balanceTraderPnl.textContent = `$${traderTotalPnl.toFixed(2)}`;
            elements.balanceTraderPnl.className = `font-medium ${traderPnlClass}`;
            elements.balanceTraderRatio.textContent = `${traderRatio.toFixed(1)}%`;

            // User balance info
            const userMargin = userPositions.reduce((sum, pos) => sum + pos.margin, 0);
            const userAvailable = userBalance - userMargin;
            const userRatio = userBalance > 0 ? (userMargin / userBalance) * 100 : 0;

            // Calculate user total position value and PnL (calculated from Hyperliquid prices)
            const userPositionValue = userPositions.reduce((sum, pos) => sum + (pos.size * pos.entryPrice), 0);
            const userTotalPnl = userPositions.reduce((sum, pos) => sum + (pos.unrealizedPnl || 0), 0);
            const userPnlClass = userTotalPnl >= 0 ? 'text-green-400' : 'text-red-400';

            elements.balanceUserTotal.textContent = `$${userBalance.toFixed(2)}`;
            elements.balanceUserAvailable.textContent = `$${userAvailable.toFixed(2)}`;
            elements.balanceUserMargin.textContent = `$${userMargin.toFixed(2)}`;
            elements.balanceUserPositionValue.textContent = `$${userPositionValue.toFixed(2)}`;
            elements.balanceUserPnl.textContent = `$${userTotalPnl.toFixed(2)}`;
            elements.balanceUserPnl.className = `font-medium ${userPnlClass}`;
            elements.balanceUserRatio.textContent = `${userRatio.toFixed(1)}%`;

            // Scaling factor
            elements.balanceScalingFactor.textContent = `${(scalingFactor * 100).toFixed(2)}%`;
        }

        // Calculate position diff (from positionDiff.js)
        function calculatePositionDiff(userPositions, targetPositions) {
            const targetMap = new Map(targetPositions.map(p => [SymbolUtils.normalize(p.symbol), p]));
            const userMap = new Map(userPositions.map(p => [SymbolUtils.normalize(p.symbol), p]));

            const toAdd = [];
            const toRemove = [];

            for (const target of targetPositions) {
                const normalizedSymbol = SymbolUtils.normalize(target.symbol);
                const user = userMap.get(normalizedSymbol);

                if (!user) {
                    // Position doesn't exist - add it
                    toAdd.push(target);
                } else {
                    // Position exists - check if size adjustment is needed
                    const sizeDiff = Math.abs(user.size - target.size);
                    const sizeRatio = target.size > 0 ? sizeDiff / target.size : 0;

                    if (sizeRatio > SIZE_TOLERANCE) {
                        // Size difference > tolerance threshold - close old position and reopen with new size
                        console.log(`‚öñÔ∏è  Position size adjustment needed for ${target.symbol}:`);
                        console.log(`   Current: ${user.size.toFixed(4)} | Target: ${target.size.toFixed(4)} | Diff: ${(sizeRatio * 100).toFixed(2)}% (>${(SIZE_TOLERANCE * 100).toFixed(0)}% threshold)`);

                        toRemove.push(user);
                        toAdd.push(target);
                    } else if (sizeRatio > 0.01) {
                        // Size difference exists but within tolerance - no action
                        console.log(`‚úì ${target.symbol} size within tolerance: ${(sizeRatio * 100).toFixed(2)}% diff (‚â§${(SIZE_TOLERANCE * 100).toFixed(0)}% threshold)`);
                    }
                }
            }

            for (const user of userPositions) {
                const normalizedSymbol = SymbolUtils.normalize(user.symbol);
                const target = targetMap.get(normalizedSymbol);

                if (!target) {
                    // Position should not exist - remove it (if not already marked for removal)
                    if (!toRemove.find(p => SymbolUtils.normalize(p.symbol) === normalizedSymbol)) {
                        toRemove.push(user);
                    }
                }
            }

            return { toAdd, toRemove };
        }

        // Fetch all positions (trader + user) - DRY principle to eliminate duplication
        async function fetchAllPositions(traderAddress, balanceInfo) {
            const { positions: traderPositions, accountData: traderAccountData } =
                await fetchTraderPositions(traderAddress);

            let userAccountData = null;
            const moonlanderWallet = getMoonlanderWallet();

            if (moonlanderWallet) {
                const moonlanderPositions = await fetchMoonlanderPositions(moonlanderWallet.address);
                // Enrich Moonlander positions with current prices and PnL from Hyperliquid
                userPositions = await enrichPositionsWithPnL(moonlanderPositions);

                // Create user account data structure for balance display
                userAccountData = {
                    marginSummary: {
                        accountValue: balanceInfo.totalEquity.toString()
                    }
                };
            }

            return { traderPositions, traderAccountData, userAccountData };
        }

        // Perform sync (following test-position-sync.js pattern)
        async function performSync() {
            const traderAddress = elements.traderAddress.value;

            try {
                log('info', 'üîÑ Starting sync...');

                // Fetch user's real-time available balance each sync round
                let balanceInfo = { freeBalance: MIN_COPY_BALANCE, totalEquity: MIN_COPY_BALANCE, positionsValue: 0 };
                const moonlanderWallet = getMoonlanderWallet();
                if (moonlanderWallet) {
                    balanceInfo = await fetchMoonlanderBalance(moonlanderWallet.address);

                    // Update stats with total equity for display
                    stats.balance = balanceInfo.totalEquity;
                    elements.copyBalance.value = balanceInfo.totalEquity.toFixed(2);
                }

                // Only check for new trades after the first sync
                if (lastTradeTimestamp !== null) {
                    const currentTradeTimestamp = await fetchLastTradeTimestamp(traderAddress);
                    const hasNewTrade = currentTradeTimestamp !== lastTradeTimestamp;

                    if (!hasNewTrade) {
                        // No new trades - just refresh position display without adjustments
                        const { traderPositions, traderAccountData, userAccountData } =
                            await fetchAllPositions(traderAddress, balanceInfo);

                        // Update position display
                        updatePositions(traderPositions, userPositions, traderAccountData, userAccountData);

                        // Update balance info display
                        if (traderAccountData) {
                            const traderTotalMargin = traderPositions.reduce((sum, pos) => sum + pos.margin, 0);
                            const userMargin = userPositions.reduce((sum, pos) => sum + pos.margin, 0);
                            updateBalanceInfo(traderAccountData, userAccountData, traderTotalMargin, balanceInfo.totalEquity, 0, 0);
                        }

                        log('info', '‚è≠Ô∏è  No new trades from trader - skipping adjustment check');
                        stats.syncs++;
                        updateStats();
                        return;
                    }

                    // Update last trade timestamp
                    const tradeTime = new Date(currentTradeTimestamp).toLocaleTimeString();
                    log('info', `üîî New trade detected at ${tradeTime}`);
                    lastTradeTimestamp = currentTradeTimestamp;
                } else {
                    // First sync - just log and set timestamp at the end
                    log('info', 'üîÑ First sync - initializing trade tracking');
                }

                // Fetch current positions for processing
                const { traderPositions, traderAccountData, userAccountData } =
                    await fetchAllPositions(traderAddress, balanceInfo);

                // Calculate trader's total margin (same as positionSyncer.js)
                const traderTotalMargin = traderPositions.reduce((sum, pos) => sum + pos.margin, 0);

                // Use total equity (free + positions) for scaling to match trader's total exposure
                log('info', `üìä Trader margin: $${traderTotalMargin.toFixed(2)} | User total equity: $${balanceInfo.totalEquity.toFixed(2)}`);

                const targetPositions = calculateTargetPositions(traderPositions, balanceInfo.totalEquity, traderAccountData, userAccountData);

                // Calculate required actions
                const actions = calculatePositionDiff(userPositions, targetPositions);

                // Execute actions if Moonlander key provided AND there are actions to take
                if (elements.moonlanderPrivateKey.value && (actions.toAdd.length > 0 || actions.toRemove.length > 0)) {
                    log('info', `üìã Actions needed: Close ${actions.toRemove.length}, Open ${actions.toAdd.length}`);

                    for (const pos of actions.toRemove) {
                        stats.removed++;
                        log('warning', `üîÑ Closing: ${pos.symbol}`);
                        await executeCopyTrade(pos, 'close');
                    }

                    for (const pos of actions.toAdd) {
                        stats.added++;
                        const margin = (pos.size * pos.entryPrice) / pos.leverage;
                        log('success', `üîÑ Opening: ${pos.symbol} ${pos.side.toUpperCase()} ${pos.size.toFixed(4)} @ market - Margin: $${margin.toFixed(2)}`);
                        await executeCopyTrade(pos, 'open');
                    }

                    log('success', '‚úÖ All actions completed');
                } else if (!elements.moonlanderPrivateKey.value) {
                    log('warning', '‚ö†Ô∏è  Wallet private key not provided - skipping execution');
                    if (actions.toAdd.length > 0 || actions.toRemove.length > 0) {
                        log('info', `Would close ${actions.toRemove.length}, open ${actions.toAdd.length} positions`);
                    }
                } else if (actions.toAdd.length === 0 && actions.toRemove.length === 0) {
                    log('info', '‚úÖ No actions needed - positions in sync');
                }

                lastTraderPositions = [...traderPositions];
                stats.syncs++;

                // Set timestamp on first sync
                if (lastTradeTimestamp === null) {
                    const currentTradeTimestamp = await fetchLastTradeTimestamp(traderAddress);
                    if (currentTradeTimestamp) {
                        lastTradeTimestamp = currentTradeTimestamp;
                        log('info', `üìç Trade tracking initialized at ${new Date(currentTradeTimestamp).toLocaleTimeString()}`);
                    }
                }

                updatePositions(traderPositions, userPositions, traderAccountData, userAccountData);
                updateActions(targetPositions);
                updateStats();

            } catch (error) {
                log('error', `‚ùå Sync failed: ${error.message}`);
                stats.errors++;
                updateStats();
            }
        }

        // Start monitoring
        async function startMonitoring() {
            // Get trader address from either dropdown selection or custom input
            const traderAddress = elements.traderAddress.value;

            // Track analytics event
            if (typeof gtag !== 'undefined') {
                gtag('event', 'start_monitoring', {
                    trader_type: elements.traderSelect.value === 'custom' ? 'custom' : 'preset',
                    trader_address: traderAddress.substring(0, 10) + '...' // Anonymize
                });
            }
            const interval = DEFAULT_SYNC_INTERVAL * 1000; // Use constant (10 seconds)

            if (!traderAddress) {
                log('error', '‚ùå Please select or enter a trader address');
                return;
            }

            try {
                log('info', 'üöÄ Initializing monitor...');

                // Create exchange for fetching public data (no API key needed)
                monitorExchange = new ccxt.hyperliquid({
                    urls: {
                        api: {
                            public: HYPERLIQUID_API_URL,
                            private: HYPERLIQUID_API_URL
                        }
                    }
                });

                // Fetch wallet balance if private key provided
                const moonlanderWallet = getMoonlanderWallet();
                if (moonlanderWallet) {
                    const balanceInfo = await fetchMoonlanderBalance(moonlanderWallet.address);
                    stats.balance = balanceInfo.totalEquity;
                    elements.copyBalance.value = balanceInfo.totalEquity.toFixed(2);
                } else {
                    stats.balance = MIN_COPY_BALANCE; // Default minimum
                    elements.copyBalance.value = MIN_COPY_BALANCE.toFixed(2);
                }

                updateStats();

                log('success', '‚úÖ Monitor initialized');
                log('info', `üë§ Trader: ${traderAddress.slice(0, 6)}...${traderAddress.slice(-4)}`);
                log('info', `üí∞ Copy Balance: $${stats.balance.toFixed(2)}`);

                // Start sync loop
                isMonitoring = true;
                elements.startButton.disabled = true;
                elements.stopButton.disabled = false;
                elements.statusDisplay.classList.remove('hidden');

                // First sync
                await performSync();

                // Setup interval
                syncInterval = setInterval(performSync, interval);

            } catch (error) {
                log('error', `‚ùå Failed to start: ${error.message}`);
                stats.errors++;
                updateStats();
            }
        }

        // Stop monitoring
        function stopMonitoring() {
            // Track analytics event
            if (typeof gtag !== 'undefined') {
                gtag('event', 'stop_monitoring', {
                    total_syncs: stats.syncs,
                    positions_added: stats.added,
                    positions_removed: stats.removed,
                    errors: stats.errors
                });
            }

            if (syncInterval) {
                clearInterval(syncInterval);
                syncInterval = null;
            }

            isMonitoring = false;
            elements.startButton.disabled = false;
            elements.stopButton.disabled = true;
            elements.statusDisplay.classList.add('hidden');

            log('warning', '‚è∏Ô∏è  Monitoring stopped');
        }
    </script>

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-PEGGJKETQ0"></script>
    <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-PEGGJKETQ0');
    </script>
</body>
<!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-NN3P9KC9"
    height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<!-- End Google Tag Manager (noscript) -->
</html>
