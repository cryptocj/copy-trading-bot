<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Position Sync Monitor</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üîÑ</text></svg>">

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#4a9eff',
                        dark: { 900: '#0a0e1a', 800: '#0f1420', 700: '#151b2e', 600: '#1a2137', 500: '#2a3550' }
                    }
                }
            }
        }
    </script>

    <!-- External Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/ccxt@4.5.11/dist/ccxt.browser.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/ethers@6.15.0/dist/ethers.umd.min.js"></script>

    <style>
        /* Table styles */
        .table-container {
            overflow-x: auto;
            border-radius: 8px;
            border: 1px solid #2a3550;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }
        .table-container table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.75rem;
            background-color: #0f1420;
        }
        .table-container thead {
            background: linear-gradient(to right, #1a2137, #151b2e);
        }
        .table-container thead tr th {
            padding: 10px 12px;
            text-align: left;
            color: #d1d5db;
            font-weight: 600;
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            border-bottom: 2px solid #2a3550;
        }
        .table-container tbody tr {
            border-bottom: 1px solid #2a3550;
        }
        .table-container tbody tr:nth-child(even) { background-color: #0f1420; }
        .table-container tbody tr:nth-child(odd) { background-color: #151b2e; }
        .table-container tbody tr:hover {
            background-color: #1a2137 !important;
        }
        .table-container tbody td {
            padding: 10px 12px;
            color: #e5e7eb;
            font-size: 0.75rem;
        }

        /* Side badges */
        .side-long {
            color: #10b981;
            background-color: rgba(16, 185, 129, 0.1);
            padding: 3px 8px;
            border-radius: 4px;
            font-weight: 600;
            font-size: 0.7rem;
            display: inline-block;
        }
        .side-short {
            color: #ef4444;
            background-color: rgba(239, 68, 68, 0.1);
            padding: 3px 8px;
            border-radius: 4px;
            font-weight: 600;
            font-size: 0.7rem;
            display: inline-block;
        }

        /* Activity log */
        #activity-log {
            max-height: 300px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.75rem;
        }
        #activity-log::-webkit-scrollbar {
            width: 8px;
        }
        #activity-log::-webkit-scrollbar-track {
            background: #0f1420;
        }
        #activity-log::-webkit-scrollbar-thumb {
            background: #2a3550;
            border-radius: 4px;
        }
        #activity-log::-webkit-scrollbar-thumb:hover {
            background: #4a9eff;
        }

        .log-entry {
            padding: 4px 8px;
            border-left: 2px solid transparent;
            margin-bottom: 2px;
        }
        .log-entry.success { border-left-color: #10b981; }
        .log-entry.error { border-left-color: #ef4444; }
        .log-entry.warning { border-left-color: #ffa726; }
        .log-entry.info { border-left-color: #4a9eff; }

        /* Monitoring Status Indicator */
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .status-indicator.active {
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }

        /* Stat card animation */
        @keyframes countUp {
            from { transform: scale(1); }
            to { transform: scale(1.1); }
        }
        .stat-card.updated {
            animation: countUp 0.3s ease-in-out;
        }
    </style>
</head>
<body class="bg-dark-900 text-gray-200">
    <div class="container mx-auto px-4 py-4 max-w-[1600px]">

        <!-- Header -->
        <header class="text-center mb-4 bg-gradient-to-br from-dark-600 to-dark-800 rounded-lg p-4 shadow-lg">
            <h1 class="text-3xl font-bold text-primary mb-1">üîÑ Position Sync Monitor</h1>
            <p class="text-gray-400 text-sm">Real-time copy trading synchronization</p>
        </header>

        <!-- Configuration Form -->
        <section class="bg-dark-700 rounded-lg shadow-lg p-4 mb-4">
            <h2 class="text-lg font-semibold text-primary mb-3">‚öôÔ∏è Configuration</h2>
            <form id="config-form" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-3">
                <div>
                    <label class="block text-sm font-medium text-gray-400 mb-1">Trader Address</label>
                    <input type="text" id="trader-address" placeholder="0x..." required
                        class="w-full px-2.5 py-1.5 text-sm bg-dark-800 border border-dark-500 rounded focus:border-primary focus:ring-1 focus:ring-primary outline-none text-gray-200">
                </div>

                <div>
                    <label class="block text-sm font-medium text-gray-400 mb-1">Monitoring API Key (Hyperliquid)</label>
                    <input type="password" id="monitoring-api-key" placeholder="0x..." required
                        class="w-full px-2.5 py-1.5 text-sm bg-dark-800 border border-dark-500 rounded focus:border-primary focus:ring-1 focus:ring-primary outline-none text-gray-200">
                </div>

                <div>
                    <label class="block text-sm font-medium text-gray-400 mb-1">Moonlander Private Key (Copy Trading)</label>
                    <input type="password" id="moonlander-private-key" placeholder="0x..."
                        class="w-full px-2.5 py-1.5 text-sm bg-dark-800 border border-dark-500 rounded focus:border-primary focus:ring-1 focus:ring-primary outline-none text-gray-200">
                </div>

                <div>
                    <label class="block text-sm font-medium text-gray-400 mb-1">Copy Balance ($)</label>
                    <input type="number" id="copy-balance" placeholder="100" value="100" min="50" step="1" required
                        class="w-full px-2.5 py-1.5 text-sm bg-dark-800 border border-dark-500 rounded focus:border-primary focus:ring-1 focus:ring-primary outline-none text-gray-200">
                </div>

                <div>
                    <label class="block text-sm font-medium text-gray-400 mb-1">Sync Interval (seconds)</label>
                    <input type="number" id="sync-interval" placeholder="30" value="30" min="10" max="300" step="5" required
                        class="w-full px-2.5 py-1.5 text-sm bg-dark-800 border border-dark-500 rounded focus:border-primary focus:ring-1 focus:ring-primary outline-none text-gray-200">
                </div>

                <div class="md:col-span-2 lg:col-span-4 flex gap-2 items-center">
                    <button type="button" id="start-button"
                        class="px-4 py-2 text-sm font-medium bg-green-600 hover:bg-green-700 text-white rounded transition">
                        ‚ñ∂Ô∏è Start Monitoring
                    </button>
                    <button type="button" id="stop-button" disabled
                        class="px-4 py-2 text-sm font-medium bg-red-600 hover:bg-red-700 disabled:bg-gray-600 disabled:cursor-not-allowed text-white rounded transition">
                        ‚è∏Ô∏è Stop
                    </button>

                    <!-- Status Indicator -->
                    <div id="status-display" class="hidden ml-auto flex items-center gap-2 px-3 py-1.5 bg-dark-800 rounded border border-dark-500">
                        <div class="status-indicator w-3 h-3 rounded-full bg-green-500 active"></div>
                        <span class="text-sm font-medium text-gray-200">Monitoring Active</span>
                    </div>
                </div>
            </form>
        </section>

        <!-- Stats Cards -->
        <div class="grid grid-cols-2 md:grid-cols-5 gap-3 mb-4">
            <div class="stat-card bg-dark-700 rounded-lg p-4 shadow-lg border border-dark-500">
                <div class="text-xs text-gray-400 mb-1">üí∞ Copy Balance</div>
                <div class="text-2xl font-bold text-gray-200" id="stat-balance">$0.00</div>
            </div>
            <div class="stat-card bg-dark-700 rounded-lg p-4 shadow-lg border border-dark-500">
                <div class="text-xs text-gray-400 mb-1">üìä Syncs</div>
                <div class="text-2xl font-bold text-gray-200" id="stat-syncs">0</div>
            </div>
            <div class="stat-card bg-dark-700 rounded-lg p-4 shadow-lg border border-dark-500">
                <div class="text-xs text-gray-400 mb-1">‚ûï Added</div>
                <div class="text-2xl font-bold text-green-400" id="stat-added">0</div>
            </div>
            <div class="stat-card bg-dark-700 rounded-lg p-4 shadow-lg border border-dark-500">
                <div class="text-xs text-gray-400 mb-1">‚ûñ Removed</div>
                <div class="text-2xl font-bold text-red-400" id="stat-removed">0</div>
            </div>
            <div class="stat-card bg-dark-700 rounded-lg p-4 shadow-lg border border-dark-500">
                <div class="text-xs text-gray-400 mb-1">‚ùå Errors</div>
                <div class="text-2xl font-bold text-red-400" id="stat-errors">0</div>
            </div>
        </div>

        <!-- Positions Grid -->
        <div class="grid grid-cols-1 lg:grid-cols-2 gap-4 mb-4">
            <!-- Trader Positions -->
            <section class="bg-dark-700 rounded-lg shadow-lg">
                <div class="p-4 border-b border-dark-500 flex justify-between items-center">
                    <h2 class="text-lg font-semibold text-primary">üë§ Trader Positions</h2>
                    <span class="text-sm text-gray-400" id="trader-position-count">0 positions</span>
                </div>
                <div class="p-4">
                    <div class="table-container">
                        <table>
                            <thead>
                                <tr>
                                    <th>Symbol</th>
                                    <th>Side</th>
                                    <th class="text-right">Size</th>
                                    <th class="text-right">Entry</th>
                                    <th class="text-right">Leverage</th>
                                    <th class="text-right">Margin</th>
                                </tr>
                            </thead>
                            <tbody id="trader-positions-body">
                                <tr><td colspan="6" class="text-center text-gray-500 py-4">Not monitoring</td></tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </section>

            <!-- Your Positions -->
            <section class="bg-dark-700 rounded-lg shadow-lg">
                <div class="p-4 border-b border-dark-500 flex justify-between items-center">
                    <h2 class="text-lg font-semibold text-primary">üìç Your Positions</h2>
                    <span class="text-sm text-gray-400" id="user-position-count">0 positions</span>
                </div>
                <div class="p-4">
                    <div class="table-container">
                        <table>
                            <thead>
                                <tr>
                                    <th>Symbol</th>
                                    <th>Side</th>
                                    <th class="text-right">Size</th>
                                    <th class="text-right">Entry</th>
                                    <th class="text-right">Leverage</th>
                                    <th class="text-right">Margin</th>
                                </tr>
                            </thead>
                            <tbody id="user-positions-body">
                                <tr><td colspan="6" class="text-center text-gray-500 py-4">Not monitoring</td></tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </section>
        </div>

        <!-- Actions Panel -->
        <section class="bg-dark-700 rounded-lg shadow-lg mb-4">
            <div class="p-4 border-b border-dark-500">
                <h2 class="text-lg font-semibold text-primary">üîÑ Required Actions</h2>
            </div>
            <div class="p-4">
                <div id="actions-content" class="space-y-2">
                    <div class="text-center text-gray-500 py-4">Start monitoring to see actions</div>
                </div>
            </div>
        </section>

        <!-- Activity Log -->
        <section class="bg-dark-700 rounded-lg shadow-lg">
            <div class="p-4 border-b border-dark-500 flex justify-between items-center">
                <h2 class="text-lg font-semibold text-primary">üìú Activity Log</h2>
                <button id="clear-log-btn" class="px-3 py-1.5 text-xs font-medium bg-dark-600 hover:bg-dark-500 text-gray-200 rounded transition">
                    Clear
                </button>
            </div>
            <div class="p-4">
                <div id="activity-log" class="bg-dark-800 rounded p-3 border border-dark-500">
                    <div class="log-entry info">
                        <span class="text-gray-500">[Ready]</span> Configure and start monitoring
                    </div>
                </div>
            </div>
        </section>
    </div>

    <script type="module">
        // Position Sync Monitor - Browser Implementation
        // Similar to test-position-sync.js but runs entirely in the browser

        let monitorExchange = null;
        let moonlanderExchange = null;
        let syncInterval = null;
        let isMonitoring = false;
        let stats = {
            balance: 100,
            syncs: 0,
            added: 0,
            removed: 0,
            errors: 0
        };
        let lastTraderPositions = [];
        let userPositions = [];

        // UI Elements
        const elements = {
            traderAddress: document.getElementById('trader-address'),
            monitoringApiKey: document.getElementById('monitoring-api-key'),
            moonlanderPrivateKey: document.getElementById('moonlander-private-key'),
            copyBalance: document.getElementById('copy-balance'),
            syncIntervalInput: document.getElementById('sync-interval'),
            startButton: document.getElementById('start-button'),
            stopButton: document.getElementById('stop-button'),
            statusDisplay: document.getElementById('status-display'),

            statBalance: document.getElementById('stat-balance'),
            statSyncs: document.getElementById('stat-syncs'),
            statAdded: document.getElementById('stat-added'),
            statRemoved: document.getElementById('stat-removed'),
            statErrors: document.getElementById('stat-errors'),

            traderPositionsBody: document.getElementById('trader-positions-body'),
            userPositionsBody: document.getElementById('user-positions-body'),
            traderPositionCount: document.getElementById('trader-position-count'),
            userPositionCount: document.getElementById('user-position-count'),

            actionsContent: document.getElementById('actions-content'),
            activityLog: document.getElementById('activity-log'),
            clearLogBtn: document.getElementById('clear-log-btn')
        };

        // Event listeners
        elements.startButton.addEventListener('click', startMonitoring);
        elements.stopButton.addEventListener('click', stopMonitoring);
        elements.clearLogBtn.addEventListener('click', clearLog);

        // Logging
        function log(level, message) {
            const timestamp = new Date().toLocaleTimeString();
            const entry = document.createElement('div');
            entry.className = `log-entry ${level}`;
            entry.innerHTML = `<span class="text-gray-500">[${timestamp}]</span> ${message}`;

            elements.activityLog.appendChild(entry);
            elements.activityLog.scrollTop = elements.activityLog.scrollHeight;

            // Keep only last 100 entries
            while (elements.activityLog.children.length > 100) {
                elements.activityLog.removeChild(elements.activityLog.firstChild);
            }
        }

        function clearLog() {
            elements.activityLog.innerHTML = '<div class="log-entry info"><span class="text-gray-500">[Cleared]</span> Log cleared</div>';
        }

        // Update stats display
        function updateStats() {
            elements.statBalance.textContent = `$${stats.balance.toFixed(2)}`;
            elements.statSyncs.textContent = stats.syncs;
            elements.statAdded.textContent = stats.added;
            elements.statRemoved.textContent = stats.removed;
            elements.statErrors.textContent = stats.errors;
        }

        // Render position row
        function renderPositionRow(pos) {
            const sideClass = (pos.side === 'long' || pos.side === 'buy') ? 'side-long' : 'side-short';
            const sideText = (pos.side === 'long' || pos.side === 'buy') ? 'LONG' : 'SHORT';
            const margin = (pos.size * pos.entryPrice) / pos.leverage;

            return `
                <tr>
                    <td class="font-semibold">${pos.symbol}</td>
                    <td><span class="${sideClass}">${sideText}</span></td>
                    <td class="text-right font-mono">${pos.size.toFixed(4)}</td>
                    <td class="text-right font-mono">$${pos.entryPrice.toLocaleString()}</td>
                    <td class="text-right">${pos.leverage.toFixed(1)}x</td>
                    <td class="text-right font-mono">$${margin.toFixed(2)}</td>
                </tr>
            `;
        }

        // Fetch trader positions (reusing logic from positionSyncer.js:225-254)
        async function fetchTraderPositions(traderAddress) {
            try {
                // Fetch positions via Hyperliquid API (same as positionSyncer.js)
                const response = await fetch(`${monitorExchange.urls.api.public}/info`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        type: 'clearinghouseState',
                        user: traderAddress,
                    }),
                });

                const data = await response.json();

                // Convert to standard format
                const positions = data.assetPositions
                    .filter((pos) => Math.abs(pos.position.szi) > 0)
                    .map((pos) => ({
                        symbol: pos.position.coin,
                        side: parseFloat(pos.position.szi) > 0 ? 'long' : 'short',
                        size: Math.abs(parseFloat(pos.position.szi)),
                        entryPrice: parseFloat(pos.position.entryPx),
                        leverage: parseFloat(pos.position.leverage.value),
                        unrealizedPnl: parseFloat(pos.position.unrealizedPnl),
                        margin: parseFloat(pos.position.marginUsed),
                    }));

                return positions;
            } catch (error) {
                log('error', `Failed to fetch trader positions: ${error.message}`);
                stats.errors++;
                return [];
            }
        }

        // Moonlander configuration
        const MOONLANDER_CONFIG = {
            rpcUrl: 'https://evm.cronos.org',
            diamondAddress: '0xE6F6351fb66f3a35313fEEFF9116698665FBEeC9',
            pairAddresses: {
                'BTC/USD': '0x062E66477Faf219F25D27dCED647BF57C3107d52',
                'ETH/USD': '0xe44Fd7fCb2b1581822D0c862B68222998a0c299a',
                'SOL/USD': '0xc9DE0F3e08162312528FF72559db82590b481800',
                'CRO/USD': '0x5C7F8A570d578ED84E63fdFA7b1eE72dEae1AE23',

                // Layer 1 chains
                'AVAX/USD': '0x8d58088D4E8Ffe75A8b6357ba5ff17B93B912640',
                'DOT/USD': '0x994047FE66406CbD646cd85B990E11D7F5dB8fC7',
                'ATOM/USD': '0xB888d8Dd1733d72681b30c00ee76BDE93ae7aa93', // Cosmos
                'NEAR/USD': '0xAFE470AE215e48c144c7158EAe3CcF0C451cb0CB',
                'ADA/USD': '0x0e517979C2c1c1522ddB0c73905e0D39b3F990c0',
                'ALGO/USD': '0x2fEfe47989214c2e74A6319076c138d395681407',
                'TON/USD': '0x8d96EA3c7F7B7A824e2C8277495007c7Fbd769ea',
                'SUI/USD': '0x81710203A7FC16797aC9899228a87fd622df9706',
                'HBAR/USD': '0xe0C7226a58f54db71eDc6289Ba2dc80349B41974',

                // Major altcoins
                'LINK/USD': '0xBc6f24649CCd67eC42342AccdCECCB2eFA27c9d9',
                'UNI/USD': '0x16aD43896f7C47a5d9Ee546c44A22205738B329c',
                'AAVE/USD': '0xE657b115bc45c0786274c824f83e3e02CE809185',
                'XRP/USD': '0xb9Ce0dd29C91E02d4620F57a66700Fc5e41d6D15',

                // Leveraged pairs (500x) - VERIFIED from successful mainnet transaction
                '500BTC/USD': '0xBAd4ccc91EF0dfFfbCAb1402C519601fbAf244EF',
            }
        };

        // TradingReaderFacet ABI (minimal - only getPositionsV2)
        const TRADING_READER_ABI = [
            {
                "inputs": [
                    {"internalType": "address", "name": "user", "type": "address"},
                    {"internalType": "address", "name": "marginToken", "type": "address"}
                ],
                "name": "getPositionsV2",
                "outputs": [{
                    "components": [
                        {"internalType": "bytes32", "name": "positionHash", "type": "bytes32"},
                        {"internalType": "string", "name": "pair", "type": "string"},
                        {"internalType": "address", "name": "pairBase", "type": "address"},
                        {"internalType": "address", "name": "marginToken", "type": "address"},
                        {"internalType": "bool", "name": "isLong", "type": "bool"},
                        {"internalType": "uint96", "name": "margin", "type": "uint96"},
                        {"internalType": "uint128", "name": "qty", "type": "uint128"},
                        {"internalType": "uint128", "name": "entryPrice", "type": "uint128"},
                        {"internalType": "uint128", "name": "stopLoss", "type": "uint128"},
                        {"internalType": "uint128", "name": "takeProfit", "type": "uint128"},
                        {"internalType": "int256", "name": "fundingFee", "type": "int256"},
                        {"internalType": "uint40", "name": "timestamp", "type": "uint40"}
                    ],
                    "internalType": "struct ITradingReader.PositionWithPairInfo[]",
                    "name": "",
                    "type": "tuple[]"
                }],
                "stateMutability": "view",
                "type": "function"
            }
        ];

        // Fetch Moonlander positions (with contract interaction)
        async function fetchMoonlanderPositions(userAddress) {
            try {
                log('info', `üìç Moonlander wallet: ${userAddress.slice(0, 6)}...${userAddress.slice(-4)}`);

                // Create provider and contract
                const provider = new ethers.JsonRpcProvider(MOONLANDER_CONFIG.rpcUrl);
                const tradingReader = new ethers.Contract(
                    MOONLANDER_CONFIG.diamondAddress,
                    TRADING_READER_ABI,
                    provider
                );

                // Fetch positions (ZeroAddress = all margin tokens)
                const positions = await tradingReader.getPositionsV2(userAddress, ethers.ZeroAddress);

                // Create address to symbol mapping
                const addressToSymbol = {};
                for (const [symbol, address] of Object.entries(MOONLANDER_CONFIG.pairAddresses)) {
                    addressToSymbol[address.toLowerCase()] = symbol;
                }

                // Parse positions
                const parsedPositions = positions.map(pos => {
                    const pairAddress = pos.pairBase.toLowerCase();
                    const symbol = addressToSymbol[pairAddress] || pos.pairBase;

                    const size = Number(pos.qty) / 1e10; // 10 decimals
                    const entryPrice = Number(pos.entryPrice) / 1e18; // 18 decimals
                    const margin = Number(pos.margin) / 1e6; // 6 decimals (USDC)

                    const positionValue = size * entryPrice;
                    const leverage = margin > 0 ? positionValue / margin : 0;

                    return {
                        tradeHash: pos.positionHash,
                        symbol,
                        pairAddress: pos.pairBase,
                        side: pos.isLong ? 'long' : 'short',
                        size,
                        entryPrice,
                        margin,
                        leverage,
                        stopLoss: Number(pos.stopLoss) / 1e18,
                        takeProfit: Number(pos.takeProfit) / 1e18,
                        fundingFee: Number(pos.fundingFee) / 1e6,
                        openTimestamp: Number(pos.timestamp)
                    };
                });

                if (parsedPositions.length > 0) {
                    log('success', `Found ${parsedPositions.length} Moonlander position(s)`);
                }

                return parsedPositions;
            } catch (error) {
                log('error', `Failed to fetch Moonlander positions: ${error.message}`);
                return [];
            }
        }

        // TradingPortalFacet ABI (minimal - open and close trades)
        const TRADING_PORTAL_ABI = [
            {
                "inputs": [
                    {
                        "components": [
                            {"internalType": "address", "name": "pairBase", "type": "address"},
                            {"internalType": "bool", "name": "isLong", "type": "bool"},
                            {"internalType": "address", "name": "tokenIn", "type": "address"},
                            {"internalType": "uint96", "name": "amountIn", "type": "uint96"},
                            {"internalType": "uint128", "name": "qty", "type": "uint128"},
                            {"internalType": "uint128", "name": "price", "type": "uint128"},
                            {"internalType": "uint128", "name": "stopLoss", "type": "uint128"},
                            {"internalType": "uint128", "name": "takeProfit", "type": "uint128"},
                            {"internalType": "uint24", "name": "broker", "type": "uint24"}
                        ],
                        "internalType": "struct IBook.OpenDataInput",
                        "name": "data",
                        "type": "tuple"
                    },
                    {"internalType": "bytes[]", "name": "priceUpdateData", "type": "bytes[]"}
                ],
                "name": "openMarketTradeWithPyth",
                "outputs": [{"internalType": "bytes32", "name": "tradeHash", "type": "bytes32"}],
                "stateMutability": "payable",
                "type": "function"
            },
            {
                "inputs": [{"internalType": "bytes32", "name": "tradeHash", "type": "bytes32"}],
                "name": "closeTrade",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            }
        ];

        const USDC_ADDRESS = '0xc21223249CA28397B4B6541dfFaEcC539BfF0c59'; // Cronos mainnet
        const ERC20_ABI = [
            'function approve(address spender, uint256 amount) returns (bool)',
            'function allowance(address owner, address spender) view returns (uint256)'
        ];

        // Execute copy trade on Moonlander
        async function executeCopyTrade(position, action) {
            try {
                const moonlanderKey = elements.moonlanderPrivateKey.value;

                if (action === 'open') {
                    log('info', `üåô Opening Moonlander: ${position.symbol} ${position.side.toUpperCase()} ${position.size.toFixed(4)} @ market - Margin: $${position.margin.toFixed(2)}`);

                    // Create signer
                    const provider = new ethers.JsonRpcProvider(MOONLANDER_CONFIG.rpcUrl);
                    const signer = new ethers.Wallet(moonlanderKey, provider);

                    // Get pair address
                    const pairAddress = MOONLANDER_CONFIG.pairAddresses[position.symbol];
                    if (!pairAddress) {
                        throw new Error(`Pair ${position.symbol} not found in config`);
                    }

                    // Fetch Pyth price
                    const pythPrice = await fetchPythPrice(position.symbol);

                    // Calculate parameters
                    const isLong = position.side === 'long' || position.side === 'buy';
                    const amountIn = ethers.parseUnits(position.margin.toFixed(6), 6); // USDC has 6 decimals
                    const qtyWei = ethers.parseUnits(position.size.toFixed(10), 10); // qty uses 10 decimals
                    const acceptablePrice = calculateAcceptablePrice(pythPrice.price, isLong);
                    const stopLossPrice = isLong ? (pythPrice.price * 50n) / 100n : (pythPrice.price * 150n) / 100n;
                    const takeProfitPrice = isLong ? (pythPrice.price * 150n) / 100n : (pythPrice.price * 50n) / 100n;

                    // Approve USDC if needed
                    const usdcContract = new ethers.Contract(USDC_ADDRESS, ERC20_ABI, signer);
                    const allowance = await usdcContract.allowance(signer.address, MOONLANDER_CONFIG.diamondAddress);
                    if (allowance < amountIn) {
                        log('info', `  Approving USDC...`);
                        const approveTx = await usdcContract.approve(MOONLANDER_CONFIG.diamondAddress, ethers.MaxUint256);
                        await approveTx.wait();
                        log('success', `  USDC approved`);
                    }

                    // Open trade
                    const tradingPortal = new ethers.Contract(MOONLANDER_CONFIG.diamondAddress, TRADING_PORTAL_ABI, signer);
                    const tx = await tradingPortal.openMarketTradeWithPyth(
                        {
                            pairBase: pairAddress,
                            isLong,
                            tokenIn: USDC_ADDRESS,
                            amountIn,
                            qty: qtyWei,
                            price: acceptablePrice,
                            stopLoss: stopLossPrice,
                            takeProfit: takeProfitPrice,
                            broker: 1
                        },
                        pythPrice.pythUpdateData,
                        {
                            gasLimit: 800000,
                            value: ethers.parseEther('0.06') // Pyth fee
                        }
                    );

                    log('info', `  ‚è≥ Waiting for confirmation...`);
                    const receipt = await tx.wait();
                    log('success', `  ‚úÖ Trade opened: ${receipt.hash}`);

                } else if (action === 'close') {
                    log('info', `üåô Closing Moonlander: ${position.symbol}`);

                    const provider = new ethers.JsonRpcProvider(MOONLANDER_CONFIG.rpcUrl);
                    const signer = new ethers.Wallet(moonlanderKey, provider);
                    const tradingPortal = new ethers.Contract(MOONLANDER_CONFIG.diamondAddress, TRADING_PORTAL_ABI, signer);

                    const tx = await tradingPortal.closeTrade(position.tradeHash, { gasLimit: 600000 });

                    log('info', `  ‚è≥ Waiting for confirmation...`);
                    const receipt = await tx.wait();
                    log('success', `  ‚úÖ Trade closed: ${receipt.hash}`);
                }

            } catch (error) {
                log('error', `‚ùå Execution error: ${error.message}`);
                stats.errors++;
            }
        }

        // Fetch Pyth price data
        async function fetchPythPrice(symbol) {
            const pythPriceIds = {
        // Major Crypto
        'BTC/USD': '0xe62df6c8b4a85fe1a67db44dc12de5db330f7ac66b72dc658afedf0f4a415b43',
        'ETH/USD': '0xff61491a931112ddf1bd8147cd1b641375f79f5825126d665480874634fd0ace',
        'SOL/USD': '0xef0d8b6fda2ceba41da15d4095d1da392a0d2f8ed0c6c7bc0f4cfac8c280b56d',
        'CRO/USD': '0x23199c2bcb1303f667e733b9934db9eca5991e765b45f5ed18bc4b231415f2fe',

        // Layer 1 Chains
        'AVAX/USD': '0x93da3352f9f1d105fdfe4971cfa80e9dd777bfc5d0f683ebb6e1294b92137bb7',
        'DOT/USD': '0xca3eed9b267293f6595901c734c7525ce8ef49adafe8284606ceb307afa2ca5b',
        'ATOM/USD': '0xb00b60f88b03a6a625a8d1c048c3f66653edf217439983d037e7222c4e612819',
        'NEAR/USD': '0xc415de8d2eba7db216527dff4b60e8f3a5311c740dadb233e13e12547e226750',
                'ADA/USD': '0x2a01deaec9e51a579277b34b122399984d0bbf57e2458a7e42fecd2829867a0d',
                'ALGO/USD': '0xfa17ceaf30d19ba51112fdcc750cc83454776f47fb0112e4af07f15f4bb1ebc0',
                'TON/USD': '0x8963217838ab4cf5cadc172203c1f0b763fbaa45f346d8ee50ba994bbcac3026',
                'SUI/USD': '0x23d7315113f5b1d3ba7a83604c44b94d79f4fd69af77f804fc7f920a6dc65744',
                'HBAR/USD': '0x8d49e2d0c97f0b0c88e3e30d0f37c2b96d52d84a08eee08ab1f8e8b7f2f9a76a',

                // Major Altcoins
                'LINK/USD': '0x8ac0c70fff57e9aefdf5edf44b51d62c2d433653cbb2cf5cc06bb115af04d221',
                'UNI/USD': '0x78d185a741d07edb3412b09008b7c5cfb9bbbd7d568bf00ba737b456ba171501',
                'AAVE/USD': '0x2b9ab1e972a281585084148ba1389800799bd4be63b957507db1349314e47445',
                'XRP/USD': '0xec5d399846a9209f3fe5881d70aae9268c94339ff9817e8d18ff19fa05eea1c8',
                'DOGE/USD': '0xdcef50dd0a4cd2dcc17e45df1676dcb336a11a61c69df7a0299b0150c672d25c',
                'SHIB/USD': '0xf0d57deca57b3da2fe63a493f4c25925fdfd8edf834b20f93e1f84dbd1504d4a',
                'PEPE/USD': '0xd69731a2e74ac1ce884fc3890f7ee324b6deb66147055249568869ed700882e4',
                'LTC/USD': '0x6e3f3fa8253588df9326580180233eb791e03b443a3ba7a1d892e73874e19a54',
                'BCH/USD': '0x3dd2b63686a450ec7290df3a1e0b583c0481f651351edfa7636f39aed55cf8a3',
                'ETC/USD': '0x7f5cc8d963fc5b3d2ae41fe5685ada89fd4f14b435f8050f28c7fd409f40c2d8',

                // Layer 2 & Scaling
                'ARB/USD': '0x3fa4252848f9f0a1480be62745a4629d9eb1322aebab8a791e344b3b9c1adcf5',
                'POL/USD': '0xffd11c5a1cfd42f80afb2df4d9f264c15f956d68153335374ec10722edd70472',

                // AI & Gaming
                'FET/USD': '0xb98e7ae8af2d298d2651eb21ab5b8b5738212e13efb43bd0dfbce7a74ba4b5d0',
                'TAO/USD': '0x8a646b51e31085f85f7feda4813d7a30ebf8e08d3e0e96a8b3c4ef6f2f6f2e64',
                'RAY/USD': '0x91568baa8beb53db23eb3fb7f22c6e8b1b82d1e1c7e4c82e0c8be7d2e95c3e3e',
                'SAND/USD': '0xabf2e3f5f2f7e75c9e2e3f5f2f7e75c9e2e3f5f2f7e75c9e2e3f5f2f7e75c9e2',
            };

            const priceId = pythIds[symbol];
            if (!priceId) {
                throw new Error(`Pyth price ID not found for ${symbol}`);
            }

            const response = await fetch(`https://hermes.pyth.network/api/latest_vaas?ids[]=${priceId}`);
            const data = await response.json();

            // Convert base64 to hex without Buffer (browser-compatible)
            const pythUpdateData = data.map(d => {
                const binaryString = atob(d.vaa);
                let hex = '0x';
                for (let i = 0; i < binaryString.length; i++) {
                    hex += ('0' + binaryString.charCodeAt(i).toString(16)).slice(-2);
                }
                return hex;
            });

            return {
                price: BigInt(data[0].price.price) * (10n ** 10n), // Convert to 18 decimals
                pythUpdateData
            };
        }

        // Calculate acceptable price with slippage
        function calculateAcceptablePrice(currentPrice, isLong, slippagePercent = 10) {
            const multiplier = isLong ? 100 + slippagePercent : 100 - slippagePercent;
            return (currentPrice * BigInt(multiplier)) / 100n;
        }

        // Update positions display
        function updatePositions(traderPositions, userPositions) {
            // Trader positions
            if (traderPositions.length > 0) {
                elements.traderPositionCount.textContent = `${traderPositions.length} position${traderPositions.length > 1 ? 's' : ''}`;
                elements.traderPositionsBody.innerHTML = traderPositions.map(renderPositionRow).join('');
            } else {
                elements.traderPositionCount.textContent = '0 positions';
                elements.traderPositionsBody.innerHTML = '<tr><td colspan="6" class="text-center text-gray-500 py-4">No positions</td></tr>';
            }

            // User positions
            if (userPositions.length > 0) {
                elements.userPositionCount.textContent = `${userPositions.length} position${userPositions.length > 1 ? 's' : ''}`;
                elements.userPositionsBody.innerHTML = userPositions.map(renderPositionRow).join('');
            } else {
                elements.userPositionCount.textContent = '0 positions';
                elements.userPositionsBody.innerHTML = '<tr><td colspan="6" class="text-center text-gray-500 py-4">No positions (execution via backend)</td></tr>';
            }
        }

        // Calculate and display actions
        function updateActions(traderPositions) {
            if (traderPositions.length === 0) {
                elements.actionsContent.innerHTML = '<div class="text-center text-green-400 py-4">‚úÖ No trader positions</div>';
                return;
            }

            let html = '<div class="bg-blue-900/20 border border-blue-500/30 rounded p-3">';
            html += '<div class="text-sm font-semibold text-blue-400 mb-2">‚ÑπÔ∏è Detected Positions</div>';
            traderPositions.forEach(pos => {
                const margin = (pos.size * pos.entryPrice) / pos.leverage;
                html += `<div class="text-xs text-gray-300 mb-1">‚Ä¢ ${pos.symbol}: ${pos.side.toUpperCase()} ${pos.size} @ $${pos.entryPrice.toLocaleString()} - Margin: $${margin.toFixed(2)}</div>`;
            });
            html += '</div>';

            elements.actionsContent.innerHTML = html;
        }

        // Calculate target positions (from positionCalculator.js)
        function calculateTargetPositions(traderPositions, copyBalance, traderBalance) {
            if (!traderPositions || traderPositions.length === 0) return [];

            const traderTotalMargin = traderPositions.reduce((sum, pos) => {
                return sum + (pos.size * pos.entryPrice) / pos.leverage;
            }, 0);

            const scalingFactor = traderTotalMargin > 0 ? copyBalance / traderTotalMargin : 0;

            return traderPositions.map(pos => {
                const traderMargin = (pos.size * pos.entryPrice) / pos.leverage;
                const copyMargin = traderMargin * scalingFactor;
                const copySize = (copyMargin * pos.leverage) / pos.entryPrice;

                return {
                    symbol: pos.symbol,
                    side: pos.side,
                    size: copySize,
                    entryPrice: pos.entryPrice,
                    leverage: pos.leverage,
                    margin: copyMargin
                };
            }).filter(pos => {
                const positionValue = pos.size * pos.entryPrice;
                return positionValue >= 200;
            });
        }

        // Calculate position diff (from positionDiff.js)
        function calculatePositionDiff(userPositions, targetPositions) {
            const normalizeSymbol = (symbol) => {
                if (!symbol) return '';
                return symbol.toUpperCase().replace(/[-/:].*$/, '').replace(/USD$|USDT$|USDC$/, '').trim();
            };

            const targetMap = new Map(targetPositions.map(p => [normalizeSymbol(p.symbol), p]));
            const userMap = new Map(userPositions.map(p => [normalizeSymbol(p.symbol), p]));

            const toAdd = [];
            const toRemove = [];

            for (const target of targetPositions) {
                const normalizedSymbol = normalizeSymbol(target.symbol);
                const user = userMap.get(normalizedSymbol);
                if (!user) {
                    toAdd.push(target);
                }
            }

            for (const user of userPositions) {
                const normalizedSymbol = normalizeSymbol(user.symbol);
                const target = targetMap.get(normalizedSymbol);
                if (!target) {
                    toRemove.push(user);
                }
            }

            return { toAdd, toRemove };
        }

        // Perform sync (following test-position-sync.js pattern)
        async function performSync() {
            const traderAddress = elements.traderAddress.value;

            try {
                log('info', 'üîÑ Starting sync...');

                const traderPositions = await fetchTraderPositions(traderAddress);
                const targetPositions = calculateTargetPositions(traderPositions, stats.balance, stats.balance);

                // Fetch Moonlander user positions if key provided
                if (elements.moonlanderPrivateKey.value) {
                    const { Wallet } = ethers;
                    const moonlanderWallet = new Wallet(elements.moonlanderPrivateKey.value);
                    const moonlanderPositions = await fetchMoonlanderPositions(moonlanderWallet.address);
                    userPositions = moonlanderPositions;
                }

                // Detect trader changes
                let hasTraderChanges = false;
                if (lastTraderPositions.length > 0) {
                    const added = traderPositions.filter(t => !lastTraderPositions.find(l => l.symbol === t.symbol));
                    const removed = lastTraderPositions.filter(l => !traderPositions.find(t => t.symbol === l.symbol));
                    hasTraderChanges = added.length > 0 || removed.length > 0;

                    if (added.length > 0) {
                        added.forEach(pos => {
                            const margin = (pos.size * pos.entryPrice) / pos.leverage;
                            log('success', `‚ûï NEW TRADER: ${pos.symbol} ${pos.side.toUpperCase()} ${pos.size.toFixed(4)} @ $${pos.entryPrice.toLocaleString()} (${pos.leverage}x) - Margin: $${margin.toFixed(2)}`);
                        });
                    }
                    if (removed.length > 0) {
                        removed.forEach(pos => {
                            log('warning', `‚ûñ CLOSED TRADER: ${pos.symbol} ${pos.side.toUpperCase()}`);
                        });
                    }
                } else {
                    log('info', `Found ${traderPositions.length} trader position(s)`);
                    hasTraderChanges = traderPositions.length > 0;
                }

                // Calculate required actions
                const actions = calculatePositionDiff(userPositions, targetPositions);

                // Execute actions if Moonlander key provided
                if (elements.moonlanderPrivateKey.value && hasTraderChanges) {
                    for (const pos of actions.toRemove) {
                        stats.removed++;
                        log('warning', `üîÑ Closing: ${pos.symbol}`);
                        await executeCopyTrade(pos, 'close');
                    }

                    for (const pos of actions.toAdd) {
                        stats.added++;
                        const margin = (pos.size * pos.entryPrice) / pos.leverage;
                        log('success', `üîÑ Opening: ${pos.symbol} ${pos.side.toUpperCase()} ${pos.size.toFixed(4)} @ market - Margin: $${margin.toFixed(2)}`);
                        await executeCopyTrade(pos, 'open');
                    }

                    if (actions.toAdd.length === 0 && actions.toRemove.length === 0) {
                        log('info', '‚úÖ No actions needed - positions in sync');
                    }
                } else if (!elements.moonlanderPrivateKey.value) {
                    log('warning', '‚ö†Ô∏è  Moonlander private key not provided - skipping execution');
                    if (actions.toAdd.length > 0 || actions.toRemove.length > 0) {
                        log('info', `Would close ${actions.toRemove.length}, open ${actions.toAdd.length} positions`);
                    }
                }

                lastTraderPositions = [...traderPositions];
                stats.syncs++;

                updatePositions(traderPositions, userPositions);
                updateActions(targetPositions);
                updateStats();

            } catch (error) {
                log('error', `‚ùå Sync failed: ${error.message}`);
                stats.errors++;
                updateStats();
            }
        }

        // Start monitoring
        async function startMonitoring() {
            const traderAddress = elements.traderAddress.value;
            const apiKey = elements.monitoringApiKey.value;
            const interval = parseInt(elements.syncIntervalInput.value) * 1000;

            if (!traderAddress || !apiKey) {
                log('error', '‚ùå Please provide trader address and API key');
                return;
            }

            try {
                log('info', 'üöÄ Initializing monitor...');

                // Create exchange
                const { Wallet } = ethers;
                const wallet = new Wallet(apiKey);

                monitorExchange = new ccxt.hyperliquid({
                    privateKey: apiKey,
                    walletAddress: wallet.address,
                    urls: {
                        api: {
                            public: 'https://api.hyperliquid.xyz',
                            private: 'https://api.hyperliquid.xyz'
                        }
                    }
                });

                stats.balance = parseFloat(elements.copyBalance.value);
                updateStats();

                log('success', '‚úÖ Monitor initialized');
                log('info', `üë§ Trader: ${traderAddress.slice(0, 6)}...${traderAddress.slice(-4)}`);
                log('info', `‚è±Ô∏è  Sync interval: ${interval/1000}s`);

                // Start sync loop
                isMonitoring = true;
                elements.startButton.disabled = true;
                elements.stopButton.disabled = false;
                elements.statusDisplay.classList.remove('hidden');

                // First sync
                await performSync();

                // Setup interval
                syncInterval = setInterval(performSync, interval);

            } catch (error) {
                log('error', `‚ùå Failed to start: ${error.message}`);
                stats.errors++;
                updateStats();
            }
        }

        // Stop monitoring
        function stopMonitoring() {
            if (syncInterval) {
                clearInterval(syncInterval);
                syncInterval = null;
            }

            isMonitoring = false;
            elements.startButton.disabled = false;
            elements.stopButton.disabled = true;
            elements.statusDisplay.classList.add('hidden');

            log('warning', '‚è∏Ô∏è  Monitoring stopped');
        }
    </script>
</body>
</html>
